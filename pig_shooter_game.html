<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gangster Pig - Endless Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.5), 0 10px 50px rgba(0, 0, 0, 0.8);
            border: 4px solid #FF1493;
        }

        #gameCanvas {
            display: block;
            background: #87CEEB;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #FF1493;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 10px rgba(255, 20, 147, 0.8);
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border: 3px solid #FF1493;
            box-shadow: inset 0 0 20px rgba(255, 20, 147, 0.3);
            image-rendering: pixelated;
        }

        #ui > div {
            margin: 8px 0;
            letter-spacing: 1px;
        }

        #ui span {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            padding: 30px;
            border: 5px solid #FF1493;
            display: none;
            z-index: 100;
            color: #FF1493;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), inset 0 0 30px rgba(255, 20, 147, 0.2);
            image-rendering: pixelated;
        }

        #shop.active {
            display: block;
        }

        #shop h2 {
            text-shadow: 3px 3px 0px #000000, 0 0 20px #FF1493;
            color: #FF1493;
        }

        #shop h3 {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        .shop-item {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 20, 147, 0.1);
            border: 3px solid #FF1493;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.2);
        }

        .shop-item:hover {
            background: rgba(255, 20, 147, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.8), inset 0 0 20px rgba(255, 20, 147, 0.4);
        }

        .shop-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-item.disabled:hover {
            transform: none;
            background: rgba(255, 20, 147, 0.1);
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.2);
        }

        .shop-item strong {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        .shop-item div {
            color: #FF69B4;
        }

        .shop-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .shop-tab {
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            color: #FFB6C1;
            background: rgba(255, 20, 147, 0.1);
            border: 3px solid #FF1493;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.2);
            font-family: 'Courier New', monospace;
        }

        .shop-tab:hover {
            background: rgba(255, 20, 147, 0.2);
            transform: scale(1.05);
        }

        .shop-tab.active {
            background: rgba(255, 20, 147, 0.4);
            color: #FF1493;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6), inset 0 0 20px rgba(255, 20, 147, 0.4);
        }

        .shop-content {
            display: none;
        }

        .shop-content.active {
            display: block;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            padding: 40px;
            border: 5px solid #FF1493;
            display: none;
            text-align: center;
            color: #FF1493;
            z-index: 100;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), inset 0 0 30px rgba(255, 20, 147, 0.2);
            image-rendering: pixelated;
        }

        #gameOver.active {
            display: block;
        }

        #gameOver h1 {
            color: #FF1493;
            text-shadow: 3px 3px 0px #000000, 0 0 20px #FF1493;
        }

        #gameOver h2, #gameOver h3 {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        button {
            margin: 10px;
            padding: 15px 35px;
            font-size: 20px;
            cursor: pointer;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            border: 3px solid #FF1493;
            font-weight: bold;
            transition: all 0.2s;
            color: #000000;
            text-shadow: 1px 1px 0px rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.5);
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
        }

        button:hover {
            background: linear-gradient(135deg, #FF69B4 0%, #FF1493 100%);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        }

        button:active {
            transform: scale(1.05);
        }

        .controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #FF1493;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 10px rgba(255, 20, 147, 0.8);
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border: 3px solid #FF1493;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.3);
        }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 20, 147, 0.03) 2px, rgba(255, 20, 147, 0.03) 4px),
                linear-gradient(135deg, #000000 0%, #1a0a1a 50%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            image-rendering: pixelated;
            box-shadow: inset 0 0 100px rgba(255, 20, 147, 0.1);
        }

        #mainMenu.hidden {
            display: none;
        }

        .menu-logo {
            width: 200px;
            height: 200px;
            margin-bottom: 30px;
            filter: drop-shadow(0 0 30px #FF1493) drop-shadow(0 0 50px #FF1493);
            animation: logoFloat 3s ease-in-out infinite;
            image-rendering: pixelated;
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
        }

        .menu-title {
            font-size: 72px;
            font-weight: bold;
            color: #FF1493;
            text-shadow: 4px 4px 0px #000000, 0 0 30px #FF1493, 0 0 50px #FF1493;
            margin-bottom: 20px;
            animation: pulse 2s infinite, glitch 5s infinite;
            letter-spacing: 5px;
            position: relative;
        }

        @keyframes glitch {
            0%, 90%, 100% { text-shadow: 4px 4px 0px #000000, 0 0 30px #FF1493, 0 0 50px #FF1493; }
            92% { text-shadow: 4px 4px 0px #000000, -2px 0 #FF1493, 2px 0 #00FFFF; }
            94% { text-shadow: 4px 4px 0px #000000, 2px 0 #FF1493, -2px 0 #00FFFF; }
        }

        .menu-subtitle {
            font-size: 28px;
            color: #FFB6C1;
            text-shadow: 3px 3px 0px #000000, 0 0 15px #FFB6C1;
            margin-bottom: 60px;
            font-weight: bold;
            letter-spacing: 3px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .menu-button {
            width: 320px;
            padding: 20px 40px;
            margin: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #000000;
            background: linear-gradient(180deg, #FF1493 0%, #FF69B4 50%, #FF1493 100%);
            border: 5px solid #FF1493;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 25px rgba(255, 20, 147, 0.6), 0 5px 0px #8B0045, inset 0 0 20px rgba(255, 255, 255, 0.2);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
            letter-spacing: 3px;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            position: relative;
            top: 0;
        }

        .menu-button:hover {
            transform: scale(1.08);
            box-shadow: 0 0 45px rgba(255, 20, 147, 0.9), 0 5px 0px #8B0045, inset 0 0 30px rgba(255, 255, 255, 0.3);
            background: linear-gradient(180deg, #FF69B4 0%, #FF1493 50%, #FF69B4 100%);
            top: -2px;
        }

        .menu-button:active {
            transform: scale(1.05);
            top: 3px;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6), 0 2px 0px #8B0045, inset 0 0 15px rgba(255, 255, 255, 0.2);
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a0a1a 0%, #2a0a2a 100%);
            padding: 50px;
            border-radius: 20px;
            border: 4px solid #FF1493;
            display: none;
            z-index: 300;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), 0 10px 30px rgba(0, 0, 0, 0.8);
        }

        #settingsMenu.active {
            display: block;
        }

        #statsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a0a1a 0%, #2a0a2a 100%);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #FF1493;
            display: none;
            z-index: 300;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), 0 10px 30px rgba(0, 0, 0, 0.8);
            min-width: 600px;
            max-width: 800px;
        }

        #statsMenu.active {
            display: block;
        }

        .stats-game-item {
            background: rgba(255, 20, 147, 0.05);
            border: 2px solid #FF1493;
            padding: 12px;
            margin: 10px 0;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 10px;
            transition: all 0.2s;
        }

        .stats-game-item:hover {
            background: rgba(255, 20, 147, 0.15);
            transform: translateX(5px);
        }

        .stats-game-item .stat-label {
            color: #FFB6C1;
            font-size: 12px;
        }

        .stats-game-item .stat-value {
            color: #FF1493;
            font-weight: bold;
            font-size: 16px;
        }

        #statsContent::-webkit-scrollbar {
            width: 10px;
        }

        #statsContent::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        #statsContent::-webkit-scrollbar-thumb {
            background: #FF1493;
            border-radius: 10px;
        }

        #statsContent::-webkit-scrollbar-thumb:hover {
            background: #FF69B4;
        }

        .settings-title {
            font-size: 42px;
            font-weight: bold;
            color: #FF1493;
            text-align: center;
            margin-bottom: 40px;
            text-shadow: 3px 3px 0px #000000, 0 0 20px #FF1493;
            letter-spacing: 2px;
        }

        .setting-item {
            margin: 30px 0;
        }

        .setting-label {
            font-size: 24px;
            color: #FFB6C1;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0px #000000;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .volume-slider {
            width: 300px;
            height: 15px;
            -webkit-appearance: none;
            appearance: none;
            background: #1a1a1a;
            outline: none;
            border: 3px solid #FF1493;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.3);
            image-rendering: pixelated;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 30px;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            cursor: pointer;
            border: 2px solid #FF1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.9);
            image-rendering: pixelated;
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 30px;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            cursor: pointer;
            border: 2px solid #FF1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.9);
            image-rendering: pixelated;
        }

        .volume-value {
            font-size: 24px;
            color: #FF1493;
            font-weight: bold;
            min-width: 60px;
            text-shadow: 2px 2px 0px #000000, 0 0 15px #FF1493;
            letter-spacing: 2px;
        }

        .settings-button {
            width: 200px;
            padding: 15px 30px;
            margin: 20px auto 0;
            display: block;
            font-size: 22px;
            font-weight: bold;
            color: #000000;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            border: 3px solid #FF1493;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.5);
        }

        .settings-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>

        <!-- Main Menu -->
        <div id="mainMenu">
            <!-- Logo SVG -->
            <svg class="menu-logo" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                <!-- Outer circle -->
                <circle cx="100" cy="100" r="95" fill="#FF1493" stroke="none"/>
                <!-- Inner circle (black) -->
                <circle cx="100" cy="100" r="85" fill="#000000" stroke="none"/>
                <!-- Smile curve -->
                <path d="M 45 90 Q 100 140 155 90" stroke="#FF1493" stroke-width="20" fill="none" stroke-linecap="round"/>
                <!-- Dot below smile -->
                <circle cx="100" cy="155" r="12" fill="#FF1493"/>
            </svg>

            <h1 class="menu-title">GANGSTER PIG</h1>
            <p class="menu-subtitle">Endless Runner Shooter</p>
            <button class="menu-button" id="startButton">START GAME</button>
            <button class="menu-button" id="statsButton">STATISTICS</button>
            <button class="menu-button" id="settingsButton">SETTINGS</button>
        </div>

        <!-- Settings Menu -->
        <div id="settingsMenu">
            <h2 class="settings-title">SETTINGS</h2>
            <div class="setting-item">
                <div class="setting-label">Sound Volume</div>
                <div class="volume-control">
                    <input type="range" min="0" max="100" value="50" class="volume-slider" id="volumeSlider">
                    <span class="volume-value" id="volumeValue">50%</span>
                </div>
            </div>
            <button class="settings-button" id="closeSettings">BACK</button>
        </div>

        <!-- Statistics Menu -->
        <div id="statsMenu">
            <h2 class="settings-title">STATISTICS</h2>
            <div id="statsContent" style="max-height: 500px; overflow-y: auto; margin: 20px 0;">
                <div style="margin-bottom: 30px;">
                    <h3 style="color: #FFB6C1; text-align: center; margin-bottom: 20px;">Overall Stats</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Best Score</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="bestScore">0</div>
                        </div>
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Total Games</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="totalGames">0</div>
                        </div>
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Total Money</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="totalMoney">$0</div>
                        </div>
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Total Kills</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="totalKills">0</div>
                        </div>
                    </div>
                </div>
                <h3 style="color: #FFB6C1; text-align: center; margin: 20px 0;">Recent Games</h3>
                <div id="recentGames" style="font-size: 14px;">
                    <!-- Recent games will be inserted here -->
                </div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="settings-button" id="clearStats" style="background: linear-gradient(135deg, #DC143C 0%, #FF1493 100%);">CLEAR ALL</button>
                <button class="settings-button" id="closeStats">BACK</button>
            </div>
        </div>

        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Money: $<span id="money">0</span></div>
            <div>Health: <span id="health">5</span>‚ù§Ô∏è <span id="armorDisplay" style="display: none;">| Armor: <span id="armor">0</span>üõ°Ô∏è</span></div>
            <div>Weapon: <span id="weapon">Colt M1911</span></div>
            <div style="font-size: 24px; font-weight: bold; color: #FFD700;">Ammo: <span id="ammo">7/7</span></div>
            <div>Level: <span id="level">1</span> | Next Shop: <span id="nextShop">500</span></div>
        </div>

        <div class="controls">
            <div>‚¨ÜÔ∏è Space - Jump | üî´ Click - Shoot | üîÑ R - Reload</div>
        </div>

        <!-- Cutscene overlay for basement scene -->
        <div id="cutscene" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 150;">
        </div>

        <!-- Merchant dialog (positioned near merchant on right side) -->
        <div id="merchantDialog" style="display: none; position: absolute; top: 30%; right: 8%; transform: translateY(-50%); background: #1a1a1a; padding: 25px; border: 5px solid #FFD700; z-index: 200; color: #FFD700; text-align: left; box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); max-width: 400px;">
            <!-- Speech bubble triangle pointing to merchant -->
            <div style="position: absolute; right: -20px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 20px solid #FFD700; border-top: 15px solid transparent; border-bottom: 15px solid transparent;"></div>
            <div style="position: absolute; right: -15px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 15px solid #1a1a1a; border-top: 12px solid transparent; border-bottom: 12px solid transparent;"></div>

            <h2 style="margin-bottom: 15px; text-shadow: 2px 2px 0px #000000; font-size: 24px;">üë§ Mysterious Merchant</h2>
            <p style="font-size: 16px; margin-bottom: 25px; color: #FFF; line-height: 1.5;">Looking for supplies, friend?<br>I have everything you need...</p>
            <div style="text-align: center;">
                <button id="acceptShop" style="padding: 12px 30px; font-size: 18px; background: #FFD700; color: #000; border: 3px solid #FFA500; cursor: pointer; font-weight: bold; margin: 5px;">Yes, show me</button>
                <button id="declineShop" style="padding: 12px 30px; font-size: 18px; background: #8B0000; color: #FFF; border: 3px solid #FF0000; cursor: pointer; font-weight: bold; margin: 5px;">Not now</button>
            </div>
        </div>

        <div id="shop">
            <h2 style="text-align: center; margin-bottom: 20px;">üè™ GANGSTER SHOP üè™</h2>
            <h3 style="text-align: center; margin-bottom: 20px;">Level <span id="shopLevel">1</span></h3>

            <!-- Shop Tabs -->
            <div class="shop-tabs">
                <div class="shop-tab active" data-tab="weapons">üî´ WEAPONS</div>
                <div class="shop-tab" data-tab="equipment">üõ°Ô∏è EQUIPMENT</div>
                <div class="shop-tab" data-tab="boosts">‚ö° BOOSTS</div>
            </div>

            <!-- Weapons Tab -->
            <div class="shop-content active" id="weapons-content">
                <div class="shop-item" id="buyColt">
                    <div><strong>üî´ Colt M1911 (starter)</strong></div>
                    <div>7 rounds | Damage: 2 | You own this ‚úì</div>
                </div>
                <div class="shop-item" id="buyShotgun">
                    <div><strong>üí• Pump Shotgun (power)</strong></div>
                    <div id="shotgunInfo">8 rounds | Damage: 3x5 | Price: $200</div>
                </div>
                <div class="shop-item" id="buySniper">
                    <div><strong>üéØ Sniper Rifle (precision)</strong></div>
                    <div id="sniperInfo">5 rounds | Damage: 10 | Price: $300</div>
                </div>
                <div class="shop-item" id="buyTommy">
                    <div><strong>üî• Tommy Gun (auto)</strong></div>
                    <div id="tommyInfo">50 rounds | Damage: 1 | Price: $350</div>
                </div>
            </div>

            <!-- Equipment Tab -->
            <div class="shop-content" id="equipment-content">
                <div class="shop-item" id="buyArmor">
                    <div><strong>üõ°Ô∏è Armor (+1 protection)</strong></div>
                    <div>Price: $100</div>
                </div>
            </div>

            <!-- Boosts Tab -->
            <div class="shop-content" id="boosts-content">
                <div class="shop-item" id="buyHealth">
                    <div><strong>‚ù§Ô∏è Health (+1 HP)</strong></div>
                    <div id="healthPrice">Price: $50</div>
                </div>
            </div>

            <button id="closeShop">Continue (next level)</button>
        </div>

        <div id="gameOver">
            <h1 style="color: #ff4444; margin-bottom: 20px;">GAME OVER</h1>
            <h2>Final Score: <span id="finalScore">0</span></h2>
            <h3>Money: $<span id="finalMoney">0</span></h3>
            <button id="restart">Play Again</button>
            <button id="mainMenuButton">Main Menu</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Load merchant head image
        const merchantHeadImg = new Image();
        merchantHeadImg.src = 'crouton.png?v=' + Date.now(); // Add cache buster to force reload

        // Game state
        const game = {
            running: false,
            score: 0,
            money: 0,
            health: 5,
            speed: 3,
            frameCount: 0,
            shopAvailable: false,
            weapon: 'colt',
            currentAmmo: 7,
            isReloading: false,
            reloadProgress: 0,
            isPumping: false,
            pumpProgress: 0,
            level: 0,
            nextShopScore: 500,
            shopMilestones: [500, 1500, 3000, 5000, 8000, 12000],
            ownedWeapons: ['colt'],
            lastShot: false,
            countdown: 0,
            muzzleFlashSize: 0,
            isNight: false,
            armor: 0,
            maxHealth: 5,
            nextPiggyBank: Math.random() * 500,
            piggyBankSpawned: false,
            volume: 0.5, // Volume level (0.0 to 1.0)
            kills: 0, // Track enemy kills
            helicopterActive: false, // Track if helicopter is alive
            nextHelicopterScore: 500, // Next score milestone for helicopter spawn (100% chance)
            nextStreetLampScore: 100, // Next score milestone for street lamp spawn
            cutsceneActive: false, // Track if cutscene is playing
            cutscenePhase: 0, // Current phase of cutscene (0: entering, 1: dialog, 2: exiting)
            cutsceneTimer: 0, // Timer for cutscene phases
            pigX: 100, // Pig position during cutscene
            merchantDialogShown: false, // Track if dialog was shown
            inShop: false, // Track if player is browsing shop
            hoveredItem: null, // Currently hovered shop item
            mouseX: 0, // Mouse position in shop
            mouseY: 0,
            autoRunning: false, // Track if pig is auto-running to basement
            basementSpawned: false // Track if basement was spawned for current milestone
        };

        // Game Statistics System
        const GameStats = {
            storageKey: 'gangsterPigStats',

            // Load all game attempts from localStorage
            loadStats() {
                const stored = localStorage.getItem(this.storageKey);
                if (stored) {
                    try {
                        return JSON.parse(stored);
                    } catch (e) {
                        return [];
                    }
                }
                return [];
            },

            // Save a new game attempt
            saveAttempt(score, money, level, weapon, kills) {
                const stats = this.loadStats();
                const attempt = {
                    id: Date.now(),
                    date: new Date().toLocaleString('ru-RU'),
                    score: score,
                    money: money,
                    level: level,
                    weapon: weapon,
                    kills: kills || 0,
                    timestamp: Date.now()
                };

                stats.push(attempt);

                // Keep only last 50 attempts to avoid storage limits
                if (stats.length > 50) {
                    stats.shift();
                }

                localStorage.setItem(this.storageKey, JSON.stringify(stats));
                return attempt;
            },

            // Get best score
            getBestScore() {
                const stats = this.loadStats();
                if (stats.length === 0) return 0;
                return Math.max(...stats.map(s => s.score));
            },

            // Get total games played
            getTotalGames() {
                return this.loadStats().length;
            },

            // Get total money earned
            getTotalMoney() {
                const stats = this.loadStats();
                return stats.reduce((sum, s) => sum + s.money, 0);
            },

            // Get stats sorted by score (descending)
            getTopScores(limit = 10) {
                const stats = this.loadStats();
                return stats.sort((a, b) => b.score - a.score).slice(0, limit);
            },

            // Clear all stats
            clearStats() {
                localStorage.removeItem(this.storageKey);
            }
        };

        // 8-bit weapon sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Function to create 8-bit weapon sounds
        function create8BitSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Different sound characteristics for each weapon
            switch(type) {
                case 'colt': // Pistol - short, sharp sound
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(game.volume * 0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;

                case 'shotgun': // Shotgun - deep, booming sound
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(game.volume * 0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;

                case 'tommy': // Tommy gun - rapid, staccato sound
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.05);
                    gainNode.gain.setValueAtTime(game.volume * 0.25, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;

                case 'sniper': // Sniper - powerful, echoing sound
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(180, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(game.volume * 0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
            }
        }

        // Play weapon sound
        function playShootSound(weaponType) {
            if (game.volume === 0) return; // Don't play if muted

            try {
                create8BitSound(weaponType);
            } catch (e) {
                console.log('Audio play failed:', e);
            }
        }

        // 8-bit Background Music System
        let musicOscillators = [];
        let musicGainNode = null;
        let musicPlaying = false;
        let currentNoteIndex = 0;

        // Noir 8-bit melody - Dark, mysterious, detective theme (frequencies in Hz)
        const melody = [
            // Opening phrase - Mysterious and moody (A minor)
            { note: 440.00, duration: 0.4 },  // A4 (slow, contemplative)
            { note: 493.88, duration: 0.3 },  // B4
            { note: 523.25, duration: 0.3 },  // C5
            { note: 587.33, duration: 0.5 },  // D5 (held)
            { note: 523.25, duration: 0.3 },  // C5
            { note: 493.88, duration: 0.3 },  // B4
            { note: 440.00, duration: 0.6 },  // A4 (long, noir mood)
            { note: 0, duration: 0.2 },       // Rest

            // Second phrase - Jazz-influenced descent
            { note: 659.25, duration: 0.4 },  // E5
            { note: 622.25, duration: 0.25 }, // D#5 (chromatic, jazzy)
            { note: 587.33, duration: 0.25 }, // D5
            { note: 554.37, duration: 0.25 }, // C#5 (chromatic)
            { note: 523.25, duration: 0.5 },  // C5
            { note: 493.88, duration: 0.3 },  // B4
            { note: 440.00, duration: 0.7 },  // A4 (resolution)
            { note: 0, duration: 0.2 },       // Rest

            // Third phrase - Minor key tension
            { note: 392.00, duration: 0.4 },  // G4
            { note: 440.00, duration: 0.3 },  // A4
            { note: 466.16, duration: 0.3 },  // A#4 (tension)
            { note: 493.88, duration: 0.5 },  // B4
            { note: 523.25, duration: 0.6 },  // C5 (held)
            { note: 493.88, duration: 0.3 },  // B4
            { note: 440.00, duration: 0.5 },  // A4
            { note: 0, duration: 0.3 },       // Rest

            // Final phrase - Melancholic ending
            { note: 329.63, duration: 0.4 },  // E4 (low, dark)
            { note: 392.00, duration: 0.3 },  // G4
            { note: 440.00, duration: 0.4 },  // A4
            { note: 523.25, duration: 0.6 },  // C5
            { note: 587.33, duration: 0.5 },  // D5
            { note: 659.25, duration: 0.8 },  // E5 (long, atmospheric)
            { note: 0, duration: 0.4 }        // Rest (breathing space)
        ];

        // Bass line - Walking bass with noir feel (lower octave for depth)
        const bassLine = [
            220.00, 220.00, 220.00, 220.00, // A3 (tonic, repeated)
            246.94, 246.94, 261.63, 261.63, // B3, C4 (movement)
            220.00, 220.00, 196.00, 196.00, // A3, G3 (descending)
            164.81, 164.81, 220.00, 220.00, // E3, A3 (resolution)

            329.63, 329.63, 329.63, 329.63, // E4 (higher, tension)
            311.13, 311.13, 293.66, 293.66, // D#4, D4 (chromatic walk)
            261.63, 261.63, 246.94, 246.94, // C4, B3 (descending)
            220.00, 220.00, 220.00, 220.00, // A3 (back to tonic)

            196.00, 196.00, 196.00, 196.00, // G3 (subdominant)
            220.00, 220.00, 233.08, 233.08, // A3, A#3 (passing tone)
            246.94, 246.94, 261.63, 261.63, // B3, C4 (building)
            220.00, 220.00, 196.00, 196.00, // A3, G3

            164.81, 164.81, 164.81, 164.81, // E3 (low, dark)
            196.00, 196.00, 220.00, 220.00, // G3, A3 (rising)
            261.63, 261.63, 293.66, 293.66, // C4, D4
            329.63, 329.63, 220.00, 220.00  // E4, A3 (final resolution)
        ];

        function playBackgroundMusic() {
            // Music disabled
            return;
            if (musicPlaying) return;
            musicPlaying = true;
            currentNoteIndex = 0;
            playNextNote();
        }

        function playNextNote() {
            if (!musicPlaying || game.volume === 0) {
                if (game.volume === 0) {
                    stopBackgroundMusic();
                }
                return;
            }

            // Clean up previous oscillators
            musicOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {}
            });
            musicOscillators = [];

            const currentNote = melody[currentNoteIndex % melody.length];
            const currentBass = bassLine[currentNoteIndex % bassLine.length];

            // Create gain node for music volume control
            if (!musicGainNode) {
                musicGainNode = audioContext.createGain();
                musicGainNode.connect(audioContext.destination);
            }
            musicGainNode.gain.value = game.volume * 0.15; // Lower volume for background music

            if (currentNote.note > 0) {
                // Melody oscillator (square wave for 8-bit sound)
                const melodyOsc = audioContext.createOscillator();
                melodyOsc.type = 'square';
                melodyOsc.frequency.setValueAtTime(currentNote.note, audioContext.currentTime);
                melodyOsc.connect(musicGainNode);
                melodyOsc.start(audioContext.currentTime);
                melodyOsc.stop(audioContext.currentTime + currentNote.duration);
                musicOscillators.push(melodyOsc);

                // Bass oscillator (triangle wave for deeper bass)
                const bassOsc = audioContext.createOscillator();
                bassOsc.type = 'triangle';
                bassOsc.frequency.setValueAtTime(currentBass, audioContext.currentTime);

                const bassGain = audioContext.createGain();
                bassGain.gain.value = 0.3; // Bass is quieter than melody
                bassOsc.connect(bassGain);
                bassGain.connect(musicGainNode);

                bassOsc.start(audioContext.currentTime);
                bassOsc.stop(audioContext.currentTime + currentNote.duration);
                musicOscillators.push(bassOsc);
            }

            currentNoteIndex++;
            setTimeout(() => playNextNote(), currentNote.duration * 1000);
        }

        function stopBackgroundMusic() {
            musicPlaying = false;
            musicOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {}
            });
            musicOscillators = [];
        }

        function updateMusicVolume() {
            if (musicGainNode) {
                musicGainNode.gain.value = game.volume * 0.15;
            }
        }

        // Player (Pig)
        const player = {
            x: 100,
            y: 450,
            width: 60,
            height: 60,
            velocityY: 0,
            gravity: 0.8,
            jumpPower: -18,
            isJumping: false,
            isCrouching: false,
            animFrame: 0,
            color: '#FF69B4'
        };

        // Weapons
        const weapons = {
            colt: {
                fireRate: 20,
                damage: 2,
                bulletSpeed: 18,
                spread: 3,
                name: 'Colt M1911',
                magSize: 7,
                reloadTime: 60,
                auto: false,
                price: 0,
                bulletCount: 1
            },
            shotgun: {
                fireRate: 45,
                damage: 3,
                bulletSpeed: 12,
                spread: 20,
                name: 'Pump Shotgun',
                magSize: 8,
                reloadTime: 90,
                auto: false,
                price: 200,
                bulletCount: 5,
                pumpTime: 30
            },
            tommy: {
                fireRate: 7,
                damage: 1,
                bulletSpeed: 15,
                spread: 6.8,
                name: 'Tommy Gun',
                magSize: 50,
                reloadTime: 120,
                auto: true,
                price: 350,
                bulletCount: 1
            },
            sniper: {
                fireRate: 90,
                damage: 10,
                bulletSpeed: 30,
                spread: 0,
                name: 'Sniper Rifle',
                magSize: 5,
                reloadTime: 120,
                auto: false,
                price: 300,
                bulletCount: 1
            }
        };

        // Shop counters layout
        const shopCounters = {
            weapons: {
                x: 100,
                y: 150,
                width: 350,
                height: 180,
                label: 'üî´ WEAPONS',
                items: [
                    { id: 'shotgun', x: 140, y: 220, width: 80, height: 40 },
                    { id: 'tommy', x: 250, y: 220, width: 75, height: 40 },
                    { id: 'sniper', x: 355, y: 220, width: 85, height: 40 }
                ]
            },
            equipment: {
                x: 500,
                y: 150,
                width: 250,
                height: 180,
                label: 'üõ°Ô∏è EQUIPMENT',
                items: [
                    { id: 'armor', x: 530, y: 200, width: 90, height: 60 },
                    { id: 'health', x: 640, y: 200, width: 90, height: 60 }
                ]
            },
            boosts: {
                x: 780,
                y: 150,
                width: 180,
                height: 180,
                label: '‚ö° BOOSTS',
                items: []
            }
        };

        // Arrays
        const bullets = [];
        const enemies = [];
        const obstacles = [];
        const buildings = [];
        const distantBuildings = []; // Far background layer
        const foregroundBuildings = []; // Close foreground layer
        const piggyBanks = [];
        const droppedBarrels = []; // Explosive barrels dropped by helicopter
        const streetLamps = []; // Street lamps that appear every 150 points
        const basementEntrances = []; // Basement shop entrances

        // Input
        const keys = {};
        let mouseDown = false;
        let shootCooldown = 0;

        // Initialize buildings for background with multiple layers
        function initBuildings() {
            // Distant buildings (far back, smaller, lighter)
            for (let i = 0; i < 6; i++) {
                const buildingHeight = 120 + Math.random() * 80;
                distantBuildings.push({
                    x: i * 250,
                    height: buildingHeight,
                    width: 180,
                    color: `hsl(${200 + Math.random() * 40}, 20%, ${45 + Math.random() * 15}%)`,
                    hasAntenna: Math.random() > 0.6
                });
            }

            // Middle buildings (main layer)
            for (let i = 0; i < 4; i++) {
                const buildingHeight = 350 + Math.random() * 130;
                const windows = [];

                // Generate random static windows
                for (let row = 0; row < Math.floor(buildingHeight / 30); row++) {
                    for (let col = 0; col < 6; col++) {
                        windows.push(Math.random() > 0.7);
                    }
                }

                buildings.push({
                    x: i * 400,
                    height: buildingHeight,
                    width: 360,
                    color: `hsl(${200 + Math.random() * 40}, 30%, ${20 + Math.random() * 20}%)`,
                    windows: windows,
                    roofType: Math.floor(Math.random() * 3), // 0=flat, 1=antenna, 2=sign
                    hasVents: Math.random() > 0.5
                });
            }

            // Foreground buildings (close, taller, darker - partial view)
            for (let i = 0; i < 3; i++) {
                const buildingHeight = 420 + Math.random() * 100;
                const windows = [];

                for (let row = 0; row < Math.floor(buildingHeight / 35); row++) {
                    for (let col = 0; col < 4; col++) {
                        windows.push(Math.random() > 0.6);
                    }
                }

                foregroundBuildings.push({
                    x: i * 500 - 100,
                    height: buildingHeight,
                    width: 280,
                    color: `hsl(${200 + Math.random() * 40}, 35%, ${12 + Math.random() * 15}%)`,
                    windows: windows
                });
            }
        }

        // Draw pixel-style pig
        function drawPig() {
            const px = player.x;
            const py = player.isCrouching ? player.y + 15 : player.y;
            const scale = player.isCrouching ? 0.8 : 1;

            // Animation frame for running
            const legOffset = !player.isJumping ? Math.sin(game.frameCount * 0.3) * 3 : 0;

            ctx.save();
            ctx.translate(px, py);
            ctx.scale(scale, scale);

            // Back leg (black pants on leg)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(15, 45 + legOffset, 8, 18);

            // Pig body (pink torso)
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(10, 25, 35, 25);

            // Black pants (lower body)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(10, 40, 35, 20); // Main pants body

            // Pants details (seams)
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(27, 40, 1, 20); // Center seam

            // Belt
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(10, 39, 35, 3); // Belt
            ctx.fillStyle = '#C0C0C0'; // Silver buckle
            ctx.fillRect(24, 39, 5, 3);

            // White shirt (gangster suit - now shows above pants)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(12, 27, 31, 13);

            // Black suit jacket
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(8, 27, 8, 20); // Left lapel
            ctx.fillRect(37, 27, 8, 20); // Right lapel

            // Red tie
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(24, 30, 5, 12);
            ctx.fillRect(22, 30, 9, 3);

            // Pig head
            ctx.fillStyle = '#FFC0CB';
            ctx.fillRect(15, 10, 25, 20);

            // Snout
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(35, 17, 10, 10);

            // Nostrils
            ctx.fillStyle = '#FF69B4';
            ctx.fillRect(37, 21, 2, 3);
            ctx.fillRect(41, 21, 2, 3);

            // Eye
            ctx.fillStyle = '#000000';
            ctx.fillRect(28, 15, 4, 4);

            // Eyebrow (angry gangster look)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(26, 13, 7, 2);

            // Ear
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(12, 15, 5, 6);

            // Front leg (animation with black pants)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(30, 45 - legOffset, 8, 18);

            // Shoes (black)
            ctx.fillStyle = '#000000';
            ctx.fillRect(13, 58 + legOffset, 10, 4);
            ctx.fillRect(28, 58 - legOffset, 10, 4);

            // Draw weapon based on current weapon
            if (game.weapon === 'colt') {
                // Colt M1911 - compact pistol
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 32, 18, 6); // Barrel
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(48, 34, 3, 8); // Magazine
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(50, 35, 6, 6); // Grip
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(61, 31, 2, 8); // Front sight

                // Muzzle flash (enhanced)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(63, 30 - flashSize/2, flashSize, 10 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(66, 32 - flashSize/4, flashSize/2, 6 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(68, 34, flashSize/4, 2);
                }
            } else if (game.weapon === 'shotgun') {
                // Pump Shotgun - longer, thicker
                ctx.fillStyle = '#654321';
                ctx.fillRect(45, 30, 28, 8); // Main body (wood)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 32, 28, 4); // Barrel (metal)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(50, 35, 8, 6); // Pump handle
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(58, 34, 4, 6); // Trigger area
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(71, 31, 2, 6); // Front sight

                // Muzzle flash (bigger for shotgun)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize * 1.5;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(73, 28 - flashSize/2, flashSize + 4, 12 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(77, 30 - flashSize/4, flashSize, 8 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(79, 32, flashSize/2, 4);
                }
            } else if (game.weapon === 'tommy') {
                // Tommy Gun - iconic with drum mag
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 30, 25, 6); // Main barrel

                // Round drum magazine (iconic)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(50, 32, 12, 12); // Drum
                ctx.fillRect(52, 30, 8, 16); // Extended drum

                // Front sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(68, 28, 3, 10);

                // Wooden grip
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(48, 36, 6, 8);

                // Foregrip
                ctx.fillStyle = '#654321';
                ctx.fillRect(58, 36, 4, 6);

                // Muzzle flash
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(70, 28 - flashSize/2, flashSize + 2, 10 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(74, 30 - flashSize/4, flashSize, 6 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(76, 32, flashSize/3, 2);
                }
            } else if (game.weapon === 'sniper') {
                // Sniper Rifle - long, precise, with scope
                // Main barrel (very long)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 32, 40, 4); // Long thin barrel

                // Receiver (body)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(48, 30, 15, 8);

                // Scope (mounted on top)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(52, 25, 12, 4); // Scope tube
                ctx.fillStyle = '#87CEEB'; // Blue tint for lens
                ctx.fillRect(53, 26, 2, 2); // Front lens
                ctx.fillRect(61, 26, 2, 2); // Rear lens

                // Stock (wooden)
                ctx.fillStyle = '#654321';
                ctx.fillRect(43, 32, 8, 6);
                ctx.fillRect(40, 33, 5, 4); // Extended stock

                // Bipod (folded)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(70, 36, 2, 4);
                ctx.fillRect(75, 36, 2, 4);

                // Magazine
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(56, 36, 8, 4);

                // Front sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(83, 30, 2, 6);

                // Muzzle flash (intense and focused)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize * 1.2;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(85, 30 - flashSize/2, flashSize + 3, 8 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(89, 31 - flashSize/4, flashSize + 2, 6 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(92, 33, flashSize, 2);
                    // Laser beam effect
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(85, 33, 100, 1);
                }
            }

            // Fedora hat (gangster style)
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(13, 5, 24, 6); // Hat brim
            ctx.fillRect(16, 0, 18, 6); // Hat top

            // Hat band
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(16, 4, 18, 2);

            ctx.restore();
        }

        // Draw city background
        function drawBackground() {
            // Day/Night cycle every 1500 points
            // Score 0-700: Day with sun at fixed position
            // Score 700-750: Sun descends and disappears behind horizon
            // Score 750: Sun fully hidden, moon starts rising from same position
            // Score 750-800: Moon rises to sun's original position
            // Score 800-1450: Night with moon at fixed position
            // Score 1450-1500: Moon descends, sun rises (cycle repeats)

            const cycleLength = 1500;
            const scoreInCycle = game.score % cycleLength;

            // Phase boundaries
            const sunsetStart = 700;      // Sun starts descending
            const sunsetEnd = 750;        // Sun fully hidden, moon starts rising
            const moonRiseEnd = 800;      // Moon fully risen
            const sunriseStart = 1450;    // Moon starts descending, sun rises

            // Determine if night
            game.isNight = scoreInCycle >= sunsetEnd && scoreInCycle < sunriseStart;

            // Calculate sky transition (0 = day, 1 = night)
            let skyTransition = 0;
            if (scoreInCycle >= sunsetStart && scoreInCycle < sunsetEnd) {
                // Transitioning to night (700-750)
                skyTransition = (scoreInCycle - sunsetStart) / (sunsetEnd - sunsetStart);
            } else if (scoreInCycle >= sunsetEnd && scoreInCycle < sunriseStart) {
                // Full night (750-1450)
                skyTransition = 1;
            } else if (scoreInCycle >= sunriseStart) {
                // Transitioning to day (1450-1500)
                skyTransition = 1 - (scoreInCycle - sunriseStart) / (cycleLength - sunriseStart);
            }

            // Sky gradient with smooth transition
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

            // Interpolate between day and night colors
            const dayColor1 = { r: 135, g: 206, b: 235 }; // #87CEEB
            const dayColor2 = { r: 224, g: 246, b: 255 }; // #E0F6FF
            const nightColor1 = { r: 10, g: 10, b: 46 };   // #0A0A2E
            const nightColor2 = { r: 26, g: 26, b: 78 };   // #1A1A4E

            const color1 = {
                r: Math.floor(dayColor1.r + (nightColor1.r - dayColor1.r) * skyTransition),
                g: Math.floor(dayColor1.g + (nightColor1.g - dayColor1.g) * skyTransition),
                b: Math.floor(dayColor1.b + (nightColor1.b - dayColor1.b) * skyTransition)
            };
            const color2 = {
                r: Math.floor(dayColor2.r + (nightColor2.r - dayColor2.r) * skyTransition),
                g: Math.floor(dayColor2.g + (nightColor2.g - dayColor2.g) * skyTransition),
                b: Math.floor(dayColor2.b + (nightColor2.b - dayColor2.b) * skyTransition)
            };

            gradient.addColorStop(0, `rgb(${color1.r}, ${color1.g}, ${color1.b})`);
            gradient.addColorStop(1, `rgb(${color2.r}, ${color2.g}, ${color2.b})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Celestial bodies
            const celestialX = canvas.width - 150;
            const skyPosition = 100;           // Normal position in sky
            const groundHorizon = canvas.height; // Horizon level

            // SUN
            if (scoreInCycle < sunsetEnd || scoreInCycle >= sunriseStart) {
                let sunY = skyPosition;
                let sunOpacity = 1;

                if (scoreInCycle >= sunsetStart && scoreInCycle < sunsetEnd) {
                    // Sun descending (700-750)
                    const sunsetProgress = (scoreInCycle - sunsetStart) / (sunsetEnd - sunsetStart);
                    sunY = skyPosition + (groundHorizon - skyPosition) * sunsetProgress;
                    sunOpacity = Math.max(0, 1 - sunsetProgress);
                } else if (scoreInCycle >= sunriseStart) {
                    // Sun rising (1450-1500)
                    const sunriseProgress = (scoreInCycle - sunriseStart) / (cycleLength - sunriseStart);
                    sunY = groundHorizon - (groundHorizon - skyPosition) * sunriseProgress;
                    sunOpacity = sunriseProgress;
                }

                if (sunOpacity > 0 && sunY < groundHorizon) {
                    // Sun
                    ctx.fillStyle = `rgba(255, 223, 0, ${sunOpacity})`;
                    ctx.fillRect(celestialX - 30, sunY - 30, 60, 60);
                    // Sun glow
                    ctx.fillStyle = `rgba(255, 200, 50, ${sunOpacity * 0.5})`;
                    ctx.fillRect(celestialX - 35, sunY - 35, 70, 70);
                    // Sun rays
                    ctx.fillStyle = `rgba(255, 223, 0, ${sunOpacity * 0.7})`;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const rx = Math.cos(angle) * 45;
                        const ry = Math.sin(angle) * 45;
                        ctx.fillRect(celestialX + rx - 2, sunY + ry - 2, 15, 4);
                    }
                }
            }

            // MOON
            if (scoreInCycle >= sunsetEnd && scoreInCycle < sunriseStart) {
                let moonY = skyPosition;
                let moonOpacity = 1;

                if (scoreInCycle < moonRiseEnd) {
                    // Moon rising (750-800)
                    const moonRiseProgress = (scoreInCycle - sunsetEnd) / (moonRiseEnd - sunsetEnd);
                    moonY = groundHorizon - (groundHorizon - skyPosition) * moonRiseProgress;
                    moonOpacity = 0.3 + 0.7 * moonRiseProgress;
                }

                if (moonY < groundHorizon) {
                    // Moon
                    ctx.fillStyle = `rgba(240, 240, 255, ${moonOpacity})`;
                    ctx.fillRect(celestialX - 25, moonY - 25, 50, 50);
                    // Moon craters
                    ctx.fillStyle = `rgba(200, 200, 220, ${moonOpacity})`;
                    ctx.fillRect(celestialX - 10, moonY - 10, 15, 15);
                    ctx.fillRect(celestialX + 5, moonY + 5, 10, 10);
                    ctx.fillRect(celestialX - 15, moonY + 8, 8, 8);
                    // Moon glow
                    ctx.fillStyle = `rgba(200, 200, 255, ${moonOpacity * 0.3})`;
                    ctx.fillRect(celestialX - 30, moonY - 30, 60, 60);
                }
            }

            // Stars at night (fade in/out with sky transition)
            if (skyTransition > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${skyTransition})`;
                for (let i = 0; i < 50; i++) {
                    const starX = (i * 123 + game.frameCount * 0.1) % canvas.width;
                    const starY = (i * 456) % 400;
                    ctx.fillRect(starX, starY, 2, 2);
                }
            }

            // LAYER 1: Distant buildings (slowest parallax)
            distantBuildings.forEach((building, index) => {
                building.x -= game.speed * 0.15;

                if (building.x + building.width < 0) {
                    building.x = canvas.width;
                    building.height = 120 + Math.random() * 80;
                    building.color = `hsl(${200 + Math.random() * 40}, 20%, ${45 + Math.random() * 15}%)`;
                    building.hasAntenna = Math.random() > 0.6;
                }

                // Building body
                ctx.fillStyle = building.color;
                ctx.fillRect(building.x, canvas.height - 100 - building.height * 0.6, building.width, building.height * 0.6);

                // Simple windows for distant buildings
                ctx.fillStyle = 'rgba(255, 255, 200, 0.4)';
                for (let j = 0; j < 4; j++) {
                    for (let i = 0; i < 3; i++) {
                        if (Math.random() > 0.5) {
                            ctx.fillRect(
                                building.x + 30 + i * 40,
                                canvas.height - 95 - building.height * 0.6 + j * 25,
                                15, 15
                            );
                        }
                    }
                }

                // Antenna on some distant buildings
                if (building.hasAntenna) {
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                    ctx.fillRect(building.x + building.width / 2 - 2, canvas.height - 100 - building.height * 0.6 - 30, 4, 30);
                    ctx.fillRect(building.x + building.width / 2 - 6, canvas.height - 100 - building.height * 0.6 - 30, 12, 6);
                }
            });

            // LAYER 2: Middle buildings (medium parallax) - MAIN LAYER
            buildings.forEach((building, index) => {
                building.x -= game.speed * 0.3;

                if (building.x + building.width < 0) {
                    building.x = canvas.width;
                    building.height = 350 + Math.random() * 130;
                    building.width = 360;
                    building.color = `hsl(${200 + Math.random() * 40}, 30%, ${20 + Math.random() * 20}%)`;
                    building.roofType = Math.floor(Math.random() * 3);
                    building.hasVents = Math.random() > 0.5;

                    // Regenerate windows
                    building.windows = [];
                    for (let row = 0; row < Math.floor(building.height / 30); row++) {
                        for (let col = 0; col < 6; col++) {
                            building.windows.push(Math.random() > 0.7);
                        }
                    }
                }

                const buildingY = canvas.height - 100 - building.height;

                // Building body
                ctx.fillStyle = building.color;
                ctx.fillRect(building.x, buildingY, building.width, building.height);

                // Building edge highlight (3D effect)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fillRect(building.x, buildingY, 8, building.height);

                // Windows
                ctx.fillStyle = 'rgba(255, 255, 150, 0.7)';
                let windowIndex = 0;
                for (let j = 0; j < Math.floor(building.height / 30); j++) {
                    for (let i = 0; i < 6; i++) {
                        if (building.windows[windowIndex]) {
                            ctx.fillRect(
                                building.x + 20 + i * 50,
                                buildingY + 10 + j * 30,
                                25, 25
                            );
                            // Window frame shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.fillRect(building.x + 20 + i * 50, buildingY + 10 + j * 30 + 25, 25, 2);
                            ctx.fillStyle = 'rgba(255, 255, 150, 0.7)';
                        }
                        windowIndex++;
                    }
                }

                // Roof details
                const roofY = buildingY;
                ctx.fillStyle = 'rgba(80, 80, 80, 0.8)';
                ctx.fillRect(building.x - 5, roofY - 8, building.width + 10, 8); // Roof ledge

                // Roof type decorations
                if (building.roofType === 1) {
                    // Antenna/radio tower
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(building.x + building.width / 2 - 3, roofY - 50, 6, 50);
                    ctx.fillRect(building.x + building.width / 2 - 10, roofY - 45, 20, 4);
                    ctx.fillRect(building.x + building.width / 2 - 8, roofY - 35, 16, 3);
                }

                // Air vents
                if (building.hasVents) {
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(building.x + 50, roofY - 15, 20, 10);
                    ctx.fillRect(building.x + 90, roofY - 15, 20, 10);
                }
            });

            // LAYER 3: Foreground buildings (fastest parallax)
            foregroundBuildings.forEach((building, index) => {
                building.x -= game.speed * 0.5;

                if (building.x + building.width < 0) {
                    building.x = canvas.width + Math.random() * 200;
                    building.height = 420 + Math.random() * 100;
                    building.color = `hsl(${200 + Math.random() * 40}, 35%, ${12 + Math.random() * 15}%)`;

                    // Regenerate windows
                    building.windows = [];
                    for (let row = 0; row < Math.floor(building.height / 35); row++) {
                        for (let col = 0; col < 4; col++) {
                            building.windows.push(Math.random() > 0.6);
                        }
                    }
                }

                const buildingY = canvas.height - 100 - building.height;

                // Building body (darker, closer)
                ctx.fillStyle = building.color;
                ctx.fillRect(building.x, buildingY, building.width, building.height);

                // Windows
                ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
                let windowIndex = 0;
                for (let j = 0; j < Math.floor(building.height / 35); j++) {
                    for (let i = 0; i < 4; i++) {
                        if (building.windows[windowIndex]) {
                            ctx.fillRect(
                                building.x + 30 + i * 55,
                                buildingY + 15 + j * 35,
                                30, 30
                            );
                        }
                        windowIndex++;
                    }
                }

                // Dark edge for depth
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(building.x + building.width - 10, buildingY, 10, building.height);
            });

            // GROUND - Detailed street with sidewalks
            // Sidewalk
            ctx.fillStyle = '#707070';
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

            // Road surface
            ctx.fillStyle = '#404040';
            ctx.fillRect(0, canvas.height - 85, canvas.width, 70);

            // Sidewalk edge
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, canvas.height - 86, canvas.width, 3);

            // Street lane lines
            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < canvas.width; i += 60) {
                ctx.fillRect((i - (game.frameCount * game.speed) % 60), canvas.height - 52, 35, 4);
            }
        }

        // Spawn enemy
        function spawnEnemy() {
            // Don't spawn ground enemies if helicopter is active
            if (game.helicopterActive) {
                return;
            }

            const types = ['alpha', 'warrior', 'beast'];
            const type = types[Math.floor(Math.random() * types.length)];

            enemies.push({
                x: canvas.width,
                y: 400,
                width: 60,
                height: 100,
                health: type === 'beast' ? 4 : (type === 'alpha' ? 3 : 2),
                type: type,
                speed: 2 + Math.random() * 1.5
            });
        }

        // Spawn helicopter enemy
        function spawnHelicopter() {
            if (game.helicopterActive) {
                return; // Only one helicopter at a time
            }

            game.helicopterActive = true;

            enemies.push({
                x: canvas.width,
                y: 250, // Flying at jump height
                width: 210, // 3x bigger (70 * 3)
                height: 150, // 3x bigger (50 * 3)
                health: 8, // 4 pistol shots (doubled from 4)
                type: 'helicopter',
                speed: 0, // Stationary - stays on right side
                dropTimer: 120, // Drop barrel every 2 seconds (120 frames at 60fps)
                dropCooldown: 120,
                targetX: canvas.width - 250 // Position on right side
            });
        }

        // Spawn obstacle
        function spawnObstacle() {
            // Check if piggy bank building is near the spawn area
            for (let i = 0; i < piggyBanks.length; i++) {
                const bank = piggyBanks[i];
                // Don't spawn obstacles if building is in or near spawn area
                // Bank extends from bank.x to bank.x + bank.width (720px wide)
                // Add buffer zone of 200px before and after building
                const bufferBefore = 200;
                const bufferAfter = 200;
                const spawnX = canvas.width;

                if (spawnX >= bank.x - bufferBefore && spawnX <= bank.x + bank.width + bufferAfter) {
                    // Building is too close, don't spawn
                    return null;
                }
            }

            const types = ['crate', 'barrel', 'tire', 'cone', 'trash', 'fence', 'hydrant', 'mailbox', 'dumpster', 'sign'];
            const type = types[Math.floor(Math.random() * types.length)];

            let width, height, y;
            if (type === 'tire') {
                width = 25;
                height = 25;
            } else if (type === 'cone') {
                width = 20;
                height = 30;
            } else if (type === 'trash') {
                width = 30;
                height = 35;
            } else if (type === 'fence') {
                width = 40;
                height = 45;
            } else if (type === 'hydrant') {
                width = 25;
                height = 35;
            } else if (type === 'mailbox') {
                width = 30;
                height = 40;
            } else if (type === 'dumpster') {
                width = 60;
                height = 55;
            } else if (type === 'sign') {
                width = 25;
                height = 50;
            } else {
                width = 20 + Math.random() * 15;
                height = 25 + Math.random() * 20;
            }

            // Position obstacles on ground
            y = 500 - height;

            const obstacle = {
                x: canvas.width,
                y: y,
                width: width,
                height: height,
                type: type,
                animFrame: 0 // For animated obstacles
            };

            obstacles.push(obstacle);
            return obstacle;
        }

        // Draw enemy (werewolf) - REALISTIC AND DETAILED
        function drawEnemy(enemy) {
            ctx.save();

            const legOffset = Math.sin(game.frameCount * 0.35 + enemy.x * 0.1) * 6;
            const ex = enemy.x;
            const ey = enemy.y;

            // Check if it's a helicopter enemy
            if (enemy.type === 'helicopter') {
                // Draw Apache-style attack helicopter (3x scale)
                const rotorOffset = Math.sin(game.frameCount * 0.5) * 4;
                const scale = 3;

                // Long tail boom (extending far back)
                ctx.fillStyle = '#3A4A2A'; // Dark military green
                ctx.fillRect(ex - 30*scale, ey + 28*scale, 50*scale, 6*scale); // Long thin tail

                // Tail rotor mechanism
                ctx.fillStyle = '#2A3A1A';
                ctx.fillRect(ex - 32*scale, ey + 25*scale, 6*scale, 12*scale); // Tail fin

                // Tail rotor (spinning vertically)
                const tailRotorRotation = (game.frameCount * 0.4) % 2;
                ctx.fillStyle = 'rgba(60, 60, 60, 0.7)';
                if (tailRotorRotation < 1) {
                    ctx.fillRect(ex - 35*scale, ey + 22*scale, 2*scale, 20*scale); // Vertical blade
                } else {
                    ctx.fillRect(ex - 36*scale, ey + 30*scale, 4*scale, 4*scale); // Horizontal blade
                }

                // Main body (sleek, angular Apache-style)
                ctx.fillStyle = '#3A4A2A';
                ctx.fillRect(ex + 10*scale, ey + 24*scale, 55*scale, 22*scale); // Main fuselage

                // Angular nose (aggressive front)
                ctx.fillStyle = '#2A3A1A';
                ctx.fillRect(ex + 60*scale, ey + 26*scale, 12*scale, 18*scale); // Pointed nose
                ctx.fillRect(ex + 70*scale, ey + 28*scale, 5*scale, 14*scale); // Nose tip

                // Cockpit (tandem seating - Apache style)
                ctx.fillStyle = '#1A2A0A';
                ctx.fillRect(ex + 45*scale, ey + 18*scale, 20*scale, 18*scale); // Rear cockpit

                // Windshield (dark tinted)
                ctx.fillStyle = '#0A1A0A';
                ctx.fillRect(ex + 47*scale, ey + 20*scale, 16*scale, 10*scale);
                ctx.fillRect(ex + 62*scale, ey + 20*scale, 10*scale, 10*scale); // Front cockpit glass

                // Wolf pilot visible (menacing)
                ctx.fillStyle = '#3A3A3A';
                ctx.fillRect(ex + 50*scale, ey + 22*scale, 6*scale, 6*scale);
                ctx.fillStyle = '#FF0000'; // Red glowing eyes
                ctx.fillRect(ex + 51*scale, ey + 24*scale, 2*scale, 2*scale);
                ctx.fillRect(ex + 54*scale, ey + 24*scale, 2*scale, 2*scale);

                // Engine exhaust ports
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(ex + 15*scale, ey + 45*scale, 8*scale, 4*scale);
                ctx.fillRect(ex + 35*scale, ey + 45*scale, 8*scale, 4*scale);

                // Stub wings with weapons
                ctx.fillStyle = '#2A3A1A';
                ctx.fillRect(ex + 20*scale, ey + 38*scale, 35*scale, 6*scale); // Wing mounts

                // Rocket pods (left side)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(ex + 18*scale, ey + 42*scale, 8*scale, 12*scale); // Left pod
                // Rockets visible
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(ex + 19*scale, ey + 44*scale, 2*scale, 8*scale);
                ctx.fillRect(ex + 22*scale, ey + 44*scale, 2*scale, 8*scale);

                // Rocket pods (right side)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(ex + 47*scale, ey + 42*scale, 8*scale, 12*scale); // Right pod
                // Rockets visible
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(ex + 48*scale, ey + 44*scale, 2*scale, 8*scale);
                ctx.fillRect(ex + 51*scale, ey + 44*scale, 2*scale, 8*scale);

                // Chain gun (nose mounted)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(ex + 72*scale, ey + 36*scale, 6*scale, 4*scale);

                // Landing gear
                ctx.fillStyle = '#2C2C2C';
                ctx.fillRect(ex + 25*scale, ey + 46*scale, 4*scale, 8*scale); // Left gear
                ctx.fillRect(ex + 45*scale, ey + 46*scale, 4*scale, 8*scale); // Right gear
                // Wheels
                ctx.fillStyle = '#1A1A1A';
                ctx.fillRect(ex + 23*scale, ey + 52*scale, 8*scale, 4*scale);
                ctx.fillRect(ex + 43*scale, ey + 52*scale, 8*scale, 4*scale);

                // Main rotor mast
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(ex + 35*scale, ey + 12*scale, 6*scale, 12*scale);

                // Main rotor hub
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(ex + 33*scale, ey + 10*scale, 10*scale, 6*scale);

                // Main rotor blades (4-blade configuration)
                const rotorRotation = (game.frameCount * 0.25) % 4;
                ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';

                if (rotorRotation < 1) {
                    // Horizontal
                    ctx.fillRect(ex - 5*scale, ey + 12*scale, 86*scale, 3*scale);
                } else if (rotorRotation < 2) {
                    // Diagonal 1
                    ctx.fillRect(ex + 15*scale, ey + 2*scale, 3*scale, 48*scale);
                    ctx.fillRect(ex + 50*scale, ey + 2*scale, 3*scale, 48*scale);
                } else if (rotorRotation < 3) {
                    // Vertical
                    ctx.fillRect(ex + 36*scale, ey - 8*scale, 3*scale, 56*scale);
                } else {
                    // Diagonal 2
                    ctx.fillRect(ex + 10*scale, ey + 2*scale, 3*scale, 48*scale);
                    ctx.fillRect(ex + 55*scale, ey + 2*scale, 3*scale, 48*scale);
                }

                // Rotor blur effect (motion blur)
                ctx.fillStyle = 'rgba(100, 100, 100, 0.15)';
                ctx.fillRect(ex - 5*scale, ey + 8*scale, 86*scale, 10*scale);

                ctx.restore();
                return;
            }

            // Different werewolf types - bigger and more menacing
            let furColor, eyeColor, chestColor, muscleTone;
            if (enemy.type === 'alpha') {
                furColor = '#3A3A3A'; // Dark gray alpha
                eyeColor = '#FF0000';
                chestColor = '#696969';
                muscleTone = '#2A2A2A';
            } else if (enemy.type === 'warrior') {
                furColor = '#5C4033'; // Brown warrior
                eyeColor = '#FF6600';
                chestColor = '#8B7355';
                muscleTone = '#4A3526';
            } else {
                furColor = '#1A1A1A'; // Black beast
                eyeColor = '#FFFF00';
                chestColor = '#3A3A3A';
                muscleTone = '#0A0A0A';
            }

            // BACK LEG (running animation)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 15, ey + 70 + legOffset, 12, 30);
            // Foot
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 12, ey + 95 + legOffset, 18, 5);

            // TAIL
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 48, ey + 45, 8, 15);
            ctx.fillRect(ex + 50, ey + 60, 6, 12);

            // BODY (muscular torso)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 10, ey + 40, 40, 35);

            // Muscle definition
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 12, ey + 42, 10, 30);
            ctx.fillRect(ex + 38, ey + 42, 10, 30);

            // CHEST (lighter fur, facing left)
            ctx.fillStyle = chestColor;
            ctx.fillRect(ex + 8, ey + 45, 20, 25);

            // SHOULDERS (broad and muscular)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 5, ey + 40, 15, 12);
            ctx.fillRect(ex + 40, ey + 40, 15, 12);

            // LEFT ARM (reaching forward aggressively)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 5, ey + 52, 10, 25);
            ctx.fillRect(ex + 3, ey + 77, 8, 15);
            // Claws
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(ex + 1, ey + 90, 3, 5);
            ctx.fillRect(ex + 5, ey + 90, 3, 5);
            ctx.fillRect(ex + 9, ey + 90, 3, 5);

            // RIGHT ARM
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 42, ey + 52, 10, 25);
            ctx.fillRect(ex + 44, ey + 77, 8, 15);
            // Claws
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(ex + 44, ey + 90, 3, 5);
            ctx.fillRect(ex + 48, ey + 90, 3, 5);
            ctx.fillRect(ex + 52, ey + 90, 3, 5);

            // NECK
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 18, ey + 30, 20, 12);

            // HEAD (large wolf head, facing LEFT toward pig)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 8, ey + 10, 35, 25);

            // Snout/Muzzle (pointing left)
            ctx.fillStyle = chestColor;
            ctx.fillRect(ex + 3, ey + 18, 15, 14);

            // Nose (wet and black)
            ctx.fillStyle = '#000000';
            ctx.fillRect(ex + 2, ey + 20, 4, 5);

            // Mouth (open with fangs)
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(ex + 4, ey + 26, 10, 5);

            // FANGS (threatening)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(ex + 5, ey + 26, 2, 6);
            ctx.fillRect(ex + 8, ey + 26, 2, 6);
            ctx.fillRect(ex + 11, ey + 26, 2, 6);
            // Bottom fangs
            ctx.fillRect(ex + 6, ey + 29, 2, 3);
            ctx.fillRect(ex + 10, ey + 29, 2, 3);

            // EYES (glowing, menacing, looking LEFT)
            ctx.fillStyle = eyeColor;
            ctx.fillRect(ex + 15, ey + 15, 5, 5);
            ctx.fillRect(ex + 24, ey + 15, 5, 5);
            // Pupils
            ctx.fillStyle = '#000000';
            ctx.fillRect(ex + 16, ey + 16, 2, 3);
            ctx.fillRect(ex + 25, ey + 16, 2, 3);

            // EARS (pointed, alert)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 12, ey + 8, 8, 5);
            ctx.fillRect(ex + 13, ey + 5, 6, 4);
            ctx.fillRect(ex + 30, ey + 8, 8, 5);
            ctx.fillRect(ex + 31, ey + 5, 6, 4);
            // Inner ear
            ctx.fillStyle = chestColor;
            ctx.fillRect(ex + 14, ey + 9, 4, 3);
            ctx.fillRect(ex + 32, ey + 9, 4, 3);

            // FRONT LEG (running animation)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 30, ey + 70 - legOffset, 12, 30);
            // Foot
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 27, ey + 95 - legOffset, 18, 5);

            // SCARS (battle-hardened)
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(ex + 20, ey + 14, 10, 2);
            ctx.fillRect(ex + 22, ey + 16, 8, 2);
            ctx.fillRect(ex + 15, ey + 50, 12, 2);
            ctx.fillRect(ex + 35, ey + 55, 10, 2);

            // Spine ridge (aggressive posture)
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 45, ey + 35, 3, 8);
            ctx.fillRect(ex + 45, ey + 45, 3, 8);

            ctx.restore();
        }

        // Draw obstacle
        function drawObstacle(obstacle) {
            if (obstacle.type === 'crate') {
                // Wooden crate
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.beginPath();
                ctx.moveTo(obstacle.x, obstacle.y);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                ctx.moveTo(obstacle.x + obstacle.width, obstacle.y);
                ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                ctx.stroke();
            } else if (obstacle.type === 'barrel') {
                // Metal barrel
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5);
                ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 5, obstacle.width, 5);
            } else if (obstacle.type === 'tire') {
                // Tire
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(obstacle.x + 5, obstacle.y + 5, obstacle.width - 10, obstacle.height - 10);
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x + 8, obstacle.y + 8, obstacle.width - 16, obstacle.height - 16);
            } else if (obstacle.type === 'cone') {
                // Traffic cone
                ctx.fillStyle = '#FF6600';
                ctx.beginPath();
                ctx.moveTo(obstacle.x + obstacle.width / 2, obstacle.y);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                ctx.closePath();
                ctx.fill();
                // White stripes
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(obstacle.x + 3, obstacle.y + 10, obstacle.width - 6, 3);
                ctx.fillRect(obstacle.x + 5, obstacle.y + 18, obstacle.width - 10, 3);
                // Base
                ctx.fillStyle = '#333333';
                ctx.fillRect(obstacle.x - 2, obstacle.y + obstacle.height, obstacle.width + 4, 3);
            } else if (obstacle.type === 'trash') {
                // Trash can
                ctx.fillStyle = '#2F4F2F';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5); // Lid
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x + 3, obstacle.y + 8, obstacle.width - 6, 3);
                ctx.fillRect(obstacle.x + 3, obstacle.y + 18, obstacle.width - 6, 3);
                // Trash overflow
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(obstacle.x + 5, obstacle.y - 5, 8, 5);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x + 15, obstacle.y - 3, 6, 3);
            } else if (obstacle.type === 'fence') {
                // Wooden fence
                ctx.fillStyle = '#654321';
                // Horizontal planks
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(obstacle.x, obstacle.y + i * 15, obstacle.width, 10);
                }
                // Vertical posts
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x + 2, obstacle.y, 8, obstacle.height);
                ctx.fillRect(obstacle.x + obstacle.width - 10, obstacle.y, 8, obstacle.height);
            } else if (obstacle.type === 'hydrant') {
                // Fire hydrant
                ctx.fillStyle = '#DC143C'; // Red
                ctx.fillRect(obstacle.x + 5, obstacle.y + 5, obstacle.width - 10, obstacle.height - 10);
                // Top cap
                ctx.fillStyle = '#B22222';
                ctx.fillRect(obstacle.x + 3, obstacle.y, obstacle.width - 6, 8);
                // Side nozzles
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.fillRect(obstacle.x, obstacle.y + 15, 5, 8);
                ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y + 15, 5, 8);
                // Base
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(obstacle.x + 2, obstacle.y + obstacle.height - 5, obstacle.width - 4, 5);
            } else if (obstacle.type === 'mailbox') {
                // Mailbox
                ctx.fillStyle = '#4169E1'; // Royal blue
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height - 15);
                // Post
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x + obstacle.width / 2 - 3, obstacle.y + obstacle.height - 15, 6, 15);
                // Flag
                ctx.fillStyle = '#DC143C';
                ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y + 5, 8, 5);
                // Door line
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x + 3, obstacle.y + 3, obstacle.width - 6, obstacle.height - 21);
            } else if (obstacle.type === 'dumpster') {
                // Large dumpster
                ctx.fillStyle = '#2F4F2F'; // Dark green
                ctx.fillRect(obstacle.x, obstacle.y + 5, obstacle.width, obstacle.height - 10);
                // Lid (slightly open)
                ctx.fillStyle = '#1C4C1C';
                ctx.fillRect(obstacle.x + 5, obstacle.y, obstacle.width - 10, 8);
                // Wheels
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x + 5, obstacle.y + obstacle.height - 5, 8, 8);
                ctx.fillRect(obstacle.x + obstacle.width - 13, obstacle.y + obstacle.height - 5, 8, 8);
                // Handles
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(obstacle.x + 2, obstacle.y + 15, 4, 15);
                ctx.fillRect(obstacle.x + obstacle.width - 6, obstacle.y + 15, 4, 15);
            } else if (obstacle.type === 'sign') {
                // Street sign
                ctx.fillStyle = '#DC143C'; // Red sign
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 25);
                // Stop text (smaller and centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('STOP', obstacle.x + obstacle.width / 2, obstacle.y + 16);
                ctx.textAlign = 'left'; // Reset text align
                // Post
                ctx.fillStyle = '#808080';
                ctx.fillRect(obstacle.x + obstacle.width / 2 - 3, obstacle.y + 25, 6, 25);
            }
        }

        // Draw basement entrance
        function drawBasementEntrance(entrance) {
            ctx.save();

            // Stairs going down
            ctx.fillStyle = '#3C3C3C'; // Dark gray concrete
            ctx.fillRect(entrance.x, entrance.y, entrance.width, entrance.height);

            // Steps (3-4 visible steps)
            ctx.fillStyle = '#2C2C2C';
            for (let i = 0; i < 4; i++) {
                const stepY = entrance.y + i * 25;
                ctx.fillRect(entrance.x + 10, stepY, entrance.width - 20, 20);
                // Step edge highlight
                ctx.fillStyle = '#4C4C4C';
                ctx.fillRect(entrance.x + 10, stepY, entrance.width - 20, 3);
                ctx.fillStyle = '#2C2C2C';
            }

            // Side walls
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(entrance.x, entrance.y, 10, entrance.height); // Left wall
            ctx.fillRect(entrance.x + entrance.width - 10, entrance.y, 10, entrance.height); // Right wall

            // Door at bottom (partially visible)
            ctx.fillStyle = '#654321'; // Brown wooden door
            ctx.fillRect(entrance.x + 20, entrance.y + 85, 80, 25);

            // Door handle
            ctx.fillStyle = '#FFD700'; // Gold handle
            ctx.fillRect(entrance.x + 85, entrance.y + 95, 8, 5);

            // Sign above entrance
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(entrance.x + 10, entrance.y - 30, entrance.width - 20, 25);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('üè™ SHOP', entrance.x + entrance.width / 2, entrance.y - 10);

            ctx.restore();
        }

        // Draw street lamp (2x taller, slightly wider)
        function drawStreetLamp(lamp) {
            const centerX = lamp.x + lamp.width / 2;

            // Lamp post (2x taller)
            ctx.fillStyle = '#2C2C2C'; // Dark gray
            ctx.fillRect(centerX - 6, lamp.y + 35, 12, 165); // Vertical post (thicker and taller)

            // Top bracket (connects lamp to post)
            ctx.fillRect(centerX - 15, lamp.y + 30, 15, 8); // Horizontal bracket

            // Lamp housing (larger)
            ctx.fillStyle = '#1C1C1C'; // Very dark gray/black
            ctx.fillRect(centerX - 20, lamp.y, 40, 35); // Lamp box (2x bigger)

            // Lamp glass/bulb
            if (game.isNight) {
                // Soft, smooth multi-layer glow effect
                // Outermost glow layer (very soft)
                const outerGradient = ctx.createRadialGradient(centerX, lamp.y + 17, 0, centerX, lamp.y + 17, 80);
                outerGradient.addColorStop(0, 'rgba(255, 215, 0, 0.15)');
                outerGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.08)');
                outerGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.03)');
                outerGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = outerGradient;
                ctx.fillRect(centerX - 80, lamp.y - 63, 160, 160);

                // Middle glow layer
                const middleGradient = ctx.createRadialGradient(centerX, lamp.y + 17, 0, centerX, lamp.y + 17, 50);
                middleGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                middleGradient.addColorStop(0.4, 'rgba(255, 215, 0, 0.15)');
                middleGradient.addColorStop(0.7, 'rgba(255, 215, 0, 0.05)');
                middleGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = middleGradient;
                ctx.fillRect(centerX - 50, lamp.y - 33, 100, 100);

                // Inner glow (bright core)
                const innerGradient = ctx.createRadialGradient(centerX, lamp.y + 17, 0, centerX, lamp.y + 17, 25);
                innerGradient.addColorStop(0, 'rgba(255, 235, 150, 0.6)');
                innerGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
                innerGradient.addColorStop(1, 'rgba(255, 215, 0, 0.1)');
                ctx.fillStyle = innerGradient;
                ctx.fillRect(centerX - 25, lamp.y - 8, 50, 50);

                // Yellow light bulb (bright center)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(centerX - 16, lamp.y + 4, 32, 28);

                // Light beam downward (soft gradient cone)
                const beamGradient = ctx.createLinearGradient(centerX, lamp.y + 35, centerX, lamp.y + 210);
                beamGradient.addColorStop(0, 'rgba(255, 215, 0, 0.25)');
                beamGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.12)');
                beamGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.05)');
                beamGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = beamGradient;
                // Cone shape (wider at bottom)
                ctx.beginPath();
                ctx.moveTo(centerX - 20, lamp.y + 35);
                ctx.lineTo(centerX - 70, lamp.y + 210);
                ctx.lineTo(centerX + 70, lamp.y + 210);
                ctx.lineTo(centerX + 20, lamp.y + 35);
                ctx.closePath();
                ctx.fill();
            } else {
                // Off during day (dark glass, larger)
                ctx.fillStyle = '#4A4A4A'; // Dark gray glass
                ctx.fillRect(centerX - 16, lamp.y + 4, 32, 28);
            }

            // Base (wider)
            ctx.fillStyle = '#3C3C3C';
            ctx.fillRect(centerX - 15, lamp.y + 200, 30, 10);
        }

        // Draw merchant character with cloak and legs (based on crouton.png mask)
        function drawMerchant(x, y) {
            ctx.save();

            // Duck body (white feathers)
            ctx.fillStyle = '#FFFFFF'; // White
            // Main body (plump, round)
            ctx.fillRect(x - 35, y + 70, 70, 80); // Main body

            // Body shading (light gray for volume)
            ctx.fillStyle = '#E8E8E8';
            ctx.fillRect(x + 20, y + 75, 15, 70); // Right side shading

            // Chest/belly (slightly rounder)
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(x - 30, y + 80, 60, 60);

            // Wings (folded on sides)
            ctx.fillStyle = '#FFFFFF';
            // Left wing
            ctx.fillRect(x - 40, y + 85, 12, 50);
            ctx.fillRect(x - 45, y + 90, 8, 40);
            // Right wing
            ctx.fillRect(x + 28, y + 85, 12, 50);
            ctx.fillRect(x + 37, y + 90, 8, 40);

            // Wing feather details
            ctx.fillStyle = '#D0D0D0';
            // Left wing feathers
            ctx.fillRect(x - 42, y + 95, 6, 8);
            ctx.fillRect(x - 42, y + 108, 6, 8);
            ctx.fillRect(x - 42, y + 121, 6, 8);
            // Right wing feathers
            ctx.fillRect(x + 36, y + 95, 6, 8);
            ctx.fillRect(x + 36, y + 108, 6, 8);
            ctx.fillRect(x + 36, y + 121, 6, 8);

            // Duck legs (orange webbed feet)
            ctx.fillStyle = '#FF8C00'; // Dark orange
            // Left leg
            ctx.fillRect(x - 18, y + 145, 10, 35);
            // Right leg
            ctx.fillRect(x + 8, y + 145, 10, 35);

            // Webbed feet
            ctx.fillStyle = '#FFA500'; // Orange
            // Left foot
            ctx.fillRect(x - 22, y + 178, 18, 8);
            ctx.fillRect(x - 20, y + 184, 4, 6); // Toe 1
            ctx.fillRect(x - 14, y + 184, 4, 6); // Toe 2
            ctx.fillRect(x - 8, y + 184, 4, 6); // Toe 3
            // Right foot
            ctx.fillRect(x + 4, y + 178, 18, 8);
            ctx.fillRect(x + 6, y + 184, 4, 6); // Toe 1
            ctx.fillRect(x + 12, y + 184, 4, 6); // Toe 2
            ctx.fillRect(x + 18, y + 184, 4, 6); // Toe 3

            // Neck (white, connecting to head)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x - 20, y + 50, 40, 25);

            // Neck shading
            ctx.fillStyle = '#E8E8E8';
            ctx.fillRect(x + 10, y + 52, 10, 20);

            // Head - use actual crouton.png image (larger and properly positioned)
            if (merchantHeadImg.complete) {
                // Draw the image centered, scaled larger to match body
                const headWidth = 110;
                const headHeight = 110;
                ctx.drawImage(merchantHeadImg, x - headWidth/2, y - 35, headWidth, headHeight);
            }

            ctx.restore();
        }

        // Draw basement scene
        function drawBasement() {
            // Dark basement background
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Brick walls (darker)
            ctx.fillStyle = '#1a1a1a';
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 20; col++) {
                    const bx = col * 60 + (row % 2) * 30;
                    const by = row * 50;
                    ctx.fillRect(bx, by, 55, 45);
                }
            }

            // Brick grout lines
            ctx.strokeStyle = '#0a0a0a';
            ctx.lineWidth = 2;
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 20; col++) {
                    const bx = col * 60 + (row % 2) * 30;
                    const by = row * 50;
                    ctx.strokeRect(bx, by, 55, 45);
                }
            }

            // Stone floor
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(0, 450, canvas.width, 50);

            // Floor tile lines
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            for (let i = 0; i < canvas.width; i += 60) {
                ctx.beginPath();
                ctx.moveTo(i, 450);
                ctx.lineTo(i, 500);
                ctx.stroke();
            }

            // Hanging lamp (dim yellow light source)
            const lampX = canvas.width / 2;
            const lampY = 100;

            // Lamp chain
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lampX, 0);
            ctx.lineTo(lampX, lampY - 20);
            ctx.stroke();

            // Lamp body
            ctx.fillStyle = '#3C3C3C';
            ctx.fillRect(lampX - 20, lampY - 20, 40, 15);

            // Lamp light (yellow glow)
            const lampGradient = ctx.createRadialGradient(lampX, lampY, 0, lampX, lampY, 150);
            lampGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
            lampGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.1)');
            lampGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = lampGradient;
            ctx.fillRect(0, 0, canvas.width, 400);

            // Actual light bulb
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(lampX - 8, lampY - 5, 16, 20);
        }

        // Draw shop counter
        function drawShopCounter(counter) {
            // Wooden board on wall
            ctx.fillStyle = '#654321'; // Dark brown wood
            ctx.fillRect(counter.x, counter.y, counter.width, counter.height);

            // Wood grain texture (horizontal lines)
            ctx.fillStyle = '#4A2F1A';
            for (let i = 0; i < 8; i++) {
                const lineY = counter.y + i * (counter.height / 8);
                ctx.fillRect(counter.x, lineY, counter.width, 2);
            }

            // Board edge/border (lighter wood frame)
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 6;
            ctx.strokeRect(counter.x, counter.y, counter.width, counter.height);

            // Nails/screws in corners
            ctx.fillStyle = '#2C2C2C';
            const nailSize = 8;
            // Top left
            ctx.fillRect(counter.x + 10, counter.y + 10, nailSize, nailSize);
            // Top right
            ctx.fillRect(counter.x + counter.width - 18, counter.y + 10, nailSize, nailSize);
            // Bottom left
            ctx.fillRect(counter.x + 10, counter.y + counter.height - 18, nailSize, nailSize);
            // Bottom right
            ctx.fillRect(counter.x + counter.width - 18, counter.y + counter.height - 18, nailSize, nailSize);

            // Label on top of board
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            // Adjust text position for equipment board (shift left)
            const textOffset = counter.label === 'üõ°Ô∏è EQUIPMENT' ? -20 : 0;
            ctx.fillText(counter.label, counter.x + counter.width / 2 + textOffset, counter.y + 35);
        }

        // Draw weapon on counter (using exact game models)
        function drawWeaponOnCounter(weaponId, x, y, width, height, isHovered) {
            ctx.save();

            // Highlight if hovered
            if (isHovered) {
                ctx.strokeStyle = '#FF69B4'; // Pink highlight
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 5, y - 5, width + 10, height + 10);

                // Glow effect
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }

            // Center the weapon in the bounding box
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            ctx.translate(centerX, centerY);

            // Draw weapon based on ID (exact game models) - centered
            if (weaponId === 'colt') {
                // Colt M1911 - compact pistol (exact copy from drawPig)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-12, -3, 18, 6); // Barrel
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-9, -1, 3, 8); // Magazine
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-7, 0, 6, 6); // Grip
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(4, -4, 2, 8); // Front sight
            } else if (weaponId === 'shotgun') {
                // Pump Shotgun - longer, thicker
                ctx.fillStyle = '#654321';
                ctx.fillRect(-14, -4, 28, 8); // Main body (wood)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-14, -2, 28, 4); // Barrel (metal)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-4, 1, 8, 6); // Pump handle
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(4, 0, 4, 6); // Trigger area
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(12, -3, 2, 6); // Front sight
            } else if (weaponId === 'tommy') {
                // Tommy Gun - iconic with drum mag
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-12, -4, 25, 6); // Main barrel

                // Round drum magazine (iconic)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-6, -2, 12, 12); // Drum
                ctx.fillRect(-4, -4, 8, 16); // Extended drum

                // Front sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(11, -6, 3, 10);

                // Wooden grip
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-8, 2, 6, 8);

                // Foregrip
                ctx.fillStyle = '#654321';
                ctx.fillRect(2, 2, 4, 6);
            } else if (weaponId === 'sniper') {
                // Sniper Rifle - long, precise, with scope
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-17, -3, 35, 6); // Main barrel (very long)

                // Scope on top
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-6, -7, 12, 4); // Scope body
                ctx.fillStyle = '#87CEEB'; // Light blue lens
                ctx.fillRect(-5, -6, 3, 2);
                ctx.fillRect(2, -6, 3, 2);

                // Stock
                ctx.fillStyle = '#654321'; // Wood
                ctx.fillRect(-12, 1, 10, 6);

                // Bipod
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(8, 3, 2, 6);
                ctx.fillRect(13, 3, 2, 6);
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw armor on counter (pixel-style tactical vest)
        function drawArmorOnCounter(x, y, width, height, isHovered) {
            ctx.save();

            if (isHovered) {
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 5, y - 5, width + 10, height + 10);
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }

            // Center the armor in the bounding box
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            ctx.translate(centerX, centerY);

            // Tactical vest (pixel-style) - centered
            // Main vest body (dark gray/black)
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(-20, -15, 40, 30);

            // Armor plates (lighter gray)
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(-18, -13, 18, 12); // Left plate
            ctx.fillRect(0, -13, 18, 12); // Right plate
            ctx.fillRect(-18, 1, 36, 12); // Bottom plate

            // Kevlar texture lines (dark lines)
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(-18, -10, 18, 2);
            ctx.fillRect(-18, -6, 18, 2);
            ctx.fillRect(0, -10, 18, 2);
            ctx.fillRect(0, -6, 18, 2);
            ctx.fillRect(-16, 5, 32, 2);
            ctx.fillRect(-16, 9, 32, 2);

            // Straps (brown)
            ctx.fillStyle = '#654321';
            ctx.fillRect(-22, -3, 4, 8); // Left strap
            ctx.fillRect(18, -3, 4, 8); // Right strap

            // Buckles (metallic)
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(-22, -1, 4, 3);
            ctx.fillRect(18, -1, 4, 3);

            // Badge/emblem (centered)
            ctx.fillStyle = '#FFD700'; // Gold badge
            ctx.fillRect(-3, 4, 6, 6);
            ctx.fillStyle = '#FF1493'; // Pink center
            ctx.fillRect(-2, 5, 4, 4);

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw health on counter
        function drawHealthOnCounter(x, y, width, height, isHovered) {
            ctx.save();

            if (isHovered) {
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 5, y - 5, width + 10, height + 10);
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }

            // Center the first aid kit in the bounding box
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            ctx.translate(centerX, centerY);

            // First aid kit box (white with red cross)
            // Main box body (white)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(-18, -12, 36, 28);

            // Box border (red outline)
            ctx.strokeStyle = '#DC143C';
            ctx.lineWidth = 3;
            ctx.strokeRect(-18, -12, 36, 28);

            // Handle on top (gray)
            ctx.fillStyle = '#808080';
            ctx.fillRect(-10, -16, 20, 5);
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 2;
            ctx.strokeRect(-10, -16, 20, 5);

            // Large red cross symbol (centered)
            ctx.fillStyle = '#DC143C';
            // Vertical bar of cross
            ctx.fillRect(-4, -8, 8, 20);
            // Horizontal bar of cross
            ctx.fillRect(-12, -2, 24, 8);

            // Small white highlights on cross for depth
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(-2, -6, 4, 4);
            ctx.fillRect(-2, 0, 4, 4);

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw item tooltip
        function drawItemTooltip(item, x, y) {
            const tooltipX = x + 80;
            const tooltipY = y - 60;
            const tooltipWidth = 200;
            const tooltipHeight = 120;

            // Tooltip background
            ctx.fillStyle = 'rgba(26, 26, 26, 0.95)';
            ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);

            // Arrow pointing to item
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(tooltipX, tooltipY + 60);
            ctx.lineTo(tooltipX - 10, tooltipY + 55);
            ctx.lineTo(tooltipX - 10, tooltipY + 65);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'left';

            let yOffset = tooltipY + 25;

            if (item.id in weapons) {
                const weapon = weapons[item.id];
                ctx.fillText(weapon.name, tooltipX + 10, yOffset);
                yOffset += 20;
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Courier New';
                ctx.fillText(`Damage: ${weapon.damage}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText(`Magazine: ${weapon.magSize}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText(`Fire Rate: ${weapon.auto ? 'Auto' : 'Semi'}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillStyle = game.ownedWeapons.includes(item.id) ? '#00FF00' : '#FFD700';
                ctx.fillText(game.ownedWeapons.includes(item.id) ? 'OWNED ‚úì' : `Price: $${weapon.price}`, tooltipX + 10, yOffset);
            } else if (item.id === 'armor') {
                ctx.fillText('Armor Vest', tooltipX + 10, yOffset);
                yOffset += 20;
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Courier New';
                ctx.fillText('+1 Protection', tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText('Absorbs damage', tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillStyle = '#FFD700';
                ctx.fillText('Price: $100', tooltipX + 10, yOffset);
            } else if (item.id === 'health') {
                ctx.fillText('Health Kit', tooltipX + 10, yOffset);
                yOffset += 20;
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Courier New';
                ctx.fillText('+1 Health', tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText(`Current: ${game.health}/${game.maxHealth}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillStyle = game.health >= game.maxHealth ? '#FF0000' : '#FFD700';
                ctx.fillText(game.health >= game.maxHealth ? 'MAX HEALTH' : 'Price: $50', tooltipX + 10, yOffset);
            }
        }

        // Shoot bullet
        function shoot() {
            const weapon = weapons[game.weapon];

            // Check if can shoot
            if (shootCooldown <= 0 && !game.isReloading && !game.isPumping && game.currentAmmo > 0) {
                const bulletY = player.isCrouching ? player.y + 35 : player.y + 30;

                // Shoot based on weapon type
                for (let i = 0; i < weapon.bulletCount; i++) {
                    const spreadAngle = (Math.random() - 0.5) * weapon.spread;

                    bullets.push({
                        x: player.x + 70,
                        y: bulletY + spreadAngle,
                        width: game.weapon === 'shotgun' ? 6 : (game.weapon === 'colt' ? 8 : 10),
                        height: 3,
                        speed: weapon.bulletSpeed,
                        damage: weapon.damage,
                        angle: spreadAngle * 0.05
                    });
                }

                game.currentAmmo--;
                shootCooldown = weapon.fireRate;
                game.muzzleFlashSize = 8; // Flash animation

                // Play weapon sound
                playShootSound(game.weapon);

                // Shotgun needs pumping after each shot
                if (game.weapon === 'shotgun') {
                    game.isPumping = true;
                    game.pumpProgress = weapon.pumpTime;
                }

                // Auto reload when empty
                if (game.currentAmmo === 0) {
                    startReload();
                }
            }
        }

        // Start reload
        function startReload() {
            const weapon = weapons[game.weapon];
            if (!game.isReloading && game.currentAmmo < weapon.magSize) {
                game.isReloading = true;
                game.reloadProgress = weapon.reloadTime;
            }
        }

        // Update game
        function update() {
            // Handle cutscene
            if (game.cutsceneActive) {
                game.cutsceneTimer++;

                // Phase 0: Pig enters basement
                if (game.cutscenePhase === 0) {
                    game.pigX += 2; // Move pig right (slower, smoother - was 5)
                    if (game.pigX >= 70) { // Stop at final position (70)
                        game.cutscenePhase = 1;
                        game.cutsceneTimer = 0;
                        // Show merchant dialog
                        document.getElementById('merchantDialog').style.display = 'block';
                    }
                }
                // Phase 1: Dialog shown, waiting for user response
                // (handled by button click events)

                return; // Don't update game while cutscene is active
            }

            if (!game.running) {
                // Handle countdown
                if (game.countdown > 0) {
                    game.countdown--;
                    if (game.countdown === 0) {
                        game.running = true;
                        // Resume background music after countdown
                        // playBackgroundMusic(); // Music disabled
                    }
                }
                return;
            }

            game.frameCount++;
            shootCooldown = Math.max(0, shootCooldown - 1);
            game.muzzleFlashSize = Math.max(0, game.muzzleFlashSize - 1);

            // Handle reload
            if (game.isReloading) {
                game.reloadProgress--;
                if (game.reloadProgress <= 0) {
                    game.isReloading = false;
                    game.currentAmmo = weapons[game.weapon].magSize;
                }
            }

            // Handle pump action (shotgun)
            if (game.isPumping) {
                game.pumpProgress--;
                if (game.pumpProgress <= 0) {
                    game.isPumping = false;
                }
            }

            // Manual reload
            if ((keys['r'] || keys['R']) && !game.isReloading && !document.getElementById('shop').classList.contains('active')) {
                startReload();
            }

            // Shooting
            const weapon = weapons[game.weapon];
            const shootPressed = mouseDown;

            // Shooting (disabled during auto-running to basement)
            if (!game.autoRunning && shootPressed && !document.getElementById('shop').classList.contains('active')) {
                // Auto or semi-auto
                if (weapon.auto) {
                    shoot(); // Tommy Gun - full auto
                } else {
                    // Semi-auto - only shoot on new press
                    if (!game.lastShot) {
                        shoot();
                    }
                }
                game.lastShot = true;
            } else {
                game.lastShot = false;
            }

            // Player physics (disabled during auto-running to basement)
            if (!game.autoRunning) {
                if (keys[' '] && !player.isJumping && !player.isCrouching) {
                    player.velocityY = player.jumpPower;
                    player.isJumping = true;
                }
            }

            player.isCrouching = false; // Crouch removed

            player.velocityY += player.gravity;
            player.y += player.velocityY;

            // Ground collision
            const groundY = player.isCrouching ? 455 : 440;
            if (player.y >= groundY) {
                player.y = groundY;
                player.velocityY = 0;
                player.isJumping = false;
            }

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].speed;
                bullets[i].y += bullets[i].angle * bullets[i].speed;

                if (bullets[i].x > canvas.width) {
                    bullets.splice(i, 1);
                }
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                // Helicopter-specific logic
                if (enemies[i].type === 'helicopter') {
                    // Move helicopter to target position (right side of screen)
                    if (enemies[i].x > enemies[i].targetX) {
                        enemies[i].x -= 3; // Move to position
                    } else {
                        enemies[i].x = enemies[i].targetX; // Lock in position
                    }

                    // Drop barrel logic (only when in position)
                    if (enemies[i].x <= enemies[i].targetX) {
                        enemies[i].dropTimer--;
                        if (enemies[i].dropTimer <= 0) {
                            // Drop explosive barrel (adjusted for 3x scale)
                            droppedBarrels.push({
                                x: enemies[i].x + 90, // Center of helicopter (30 * 3)
                                y: enemies[i].y + 135, // Bottom of helicopter (45 * 3)
                                width: 20,
                                height: 25,
                                velocityY: 2,
                                exploding: false,
                                explosionTimer: 0,
                                onGround: false // Track if barrel has landed
                            });
                            enemies[i].dropTimer = enemies[i].dropCooldown;
                        }
                    }
                } else {
                    // Normal enemy movement
                    enemies[i].x -= enemies[i].speed + game.speed;
                }

                // Check bullet collision
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (bullets[j].x < enemies[i].x + enemies[i].width &&
                        bullets[j].x + bullets[j].width > enemies[i].x &&
                        bullets[j].y < enemies[i].y + enemies[i].height &&
                        bullets[j].y + bullets[j].height > enemies[i].y) {

                        enemies[i].health -= bullets[j].damage;
                        bullets.splice(j, 1);

                        if (enemies[i].health <= 0) {
                            game.score += 10;
                            game.money += 5;
                            game.kills++; // Increment kill counter

                            // If helicopter is killed, reset flag
                            if (enemies[i].type === 'helicopter') {
                                game.helicopterActive = false;
                            }

                            enemies.splice(i, 1);
                            break;
                        }
                    }
                }

                // Check player collision (adjusted for bigger werewolves)
                if (i >= 0 && enemies[i]) {
                    const playerHeight = player.isCrouching ? 50 : 62;
                    const playerY = player.isCrouching ? player.y + 15 : player.y;

                    if (enemies[i].x < player.x + 50 &&
                        enemies[i].x + 50 > player.x &&
                        enemies[i].y < playerY + playerHeight &&
                        enemies[i].y + 90 > playerY) {

                        // Check armor first
                        if (game.armor > 0) {
                            game.armor--;
                        } else {
                            game.health--;
                        }

                        enemies.splice(i, 1);

                        if (game.health <= 0) {
                            gameOver();
                        }
                    }
                }

                // Remove off-screen enemies
                if (i >= 0 && enemies[i] && enemies[i].x < -enemies[i].width) {
                    // If helicopter flies off screen, reset flag
                    if (enemies[i].type === 'helicopter') {
                        game.helicopterActive = false;
                    }
                    enemies.splice(i, 1);
                    game.score += 1;
                }
            }

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= game.speed;

                // Check player collision with obstacles
                const playerHeight = player.isCrouching ? 50 : 62;
                const playerY = player.isCrouching ? player.y + 15 : player.y;
                const playerBottom = playerY + playerHeight;
                const playerRight = player.x + 45;

                // Check if there's any overlap
                const isOverlapping = obstacles[i].x < playerRight &&
                    obstacles[i].x + obstacles[i].width > player.x &&
                    obstacles[i].y < playerBottom &&
                    obstacles[i].y + obstacles[i].height > playerY;

                if (isOverlapping) {
                    // Check if player is coming from above (landing on top)
                    const isLandingOnTop = player.velocityY > 0 && // Falling down (must be positive velocity)
                        playerBottom - player.velocityY <= obstacles[i].y + 5; // Was above obstacle in previous frame

                    if (isLandingOnTop) {
                        // Landing on top - NO DAMAGE, can stand on it
                        player.y = obstacles[i].y - playerHeight + (player.isCrouching ? 15 : 0);
                        player.velocityY = 0;
                        player.isJumping = false;
                    } else {
                        // Side collision or ground collision - take damage (armor first)
                        if (game.armor > 0) {
                            game.armor--;
                        } else {
                            game.health--;
                        }

                        obstacles.splice(i, 1);

                        if (game.health <= 0) {
                            gameOver();
                        }
                    }
                } else if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                    game.score += 2;
                }
            }

            // Update dropped barrels
            for (let i = droppedBarrels.length - 1; i >= 0; i--) {
                const barrel = droppedBarrels[i];

                // If barrel is on ground, stop falling and act as obstacle
                if (!barrel.onGround && barrel.y >= 485) {
                    barrel.onGround = true;
                    barrel.y = 485; // Lock to ground
                    barrel.velocityY = 0;
                }

                // Move barrel down if still falling
                if (!barrel.onGround) {
                    barrel.y += barrel.velocityY;
                }

                // Always move with game speed
                barrel.x -= game.speed;

                // Handle explosion animation
                if (barrel.exploding) {
                    barrel.explosionTimer--;
                    if (barrel.explosionTimer <= 0) {
                        droppedBarrels.splice(i, 1);
                        continue;
                    }
                }

                // Check collision with player (only if not exploding yet)
                if (!barrel.exploding) {
                    const playerHeight = player.isCrouching ? 50 : 62;
                    const playerY = player.isCrouching ? player.y + 15 : player.y;

                    if (barrel.x < player.x + 50 &&
                        barrel.x + barrel.width > player.x &&
                        barrel.y < playerY + playerHeight &&
                        barrel.y + barrel.height > playerY) {

                        // Trigger explosion and damage player
                        barrel.exploding = true;
                        barrel.explosionTimer = 30;

                        // Damage player
                        if (game.armor > 0) {
                            game.armor--;
                        } else {
                            game.health--;
                        }

                        if (game.health <= 0) {
                            gameOver();
                        }
                    }
                }

                // Remove if off-screen
                if (barrel.x < -barrel.width) {
                    droppedBarrels.splice(i, 1);
                }
            }

            // Spawn enemies and obstacles (10% less enemies)
            if (game.frameCount % 200 === 0) {
                spawnEnemy();
            }

            // Reduced obstacle frequency (from 200 to 300 frames)
            if (game.frameCount % 300 === 0) {
                // Fewer obstacles - mostly single, sometimes double
                const obstacleCount = Math.random() > 0.8 ? 2 : 1;

                for (let i = 0; i < obstacleCount; i++) {
                    const obstacle = spawnObstacle();
                    if (obstacle) {
                        obstacle.x += i * 100; // More spacing between obstacles
                    }
                }
            }

            // Spawn piggy bank building at random intervals
            const currentCycle = Math.floor(game.score / 500);
            const scoreInCycle = game.score % 500;

            if (!game.piggyBankSpawned && scoreInCycle >= game.nextPiggyBank) {
                piggyBanks.push({
                    x: canvas.width,
                    y: 300,  // Higher up
                    width: 720,  // 6x wider (120 * 6)
                    height: 200, // Much taller
                    broken: false
                });
                game.piggyBankSpawned = true;
            }

            // Reset piggy bank spawn for next cycle
            if (scoreInCycle === 0 && game.piggyBankSpawned) {
                game.piggyBankSpawned = false;
                game.nextPiggyBank = Math.random() * 500;
            }

            // Spawn helicopter every 500 points (100% chance)
            if (game.score >= game.nextHelicopterScore && !game.helicopterActive) {
                spawnHelicopter();
                game.nextHelicopterScore += 500;
            }

            // Spawn street lamp every 150 points
            if (game.score >= game.nextStreetLampScore) {
                streetLamps.push({
                    x: canvas.width,
                    y: 290, // Position on ground (500 - 210 for lamp height)
                    width: 35, // Width for hitbox (slightly wider)
                    height: 210 // Total height of lamp (2x taller: 105 * 2)
                });
                game.nextStreetLampScore += 100;
            }

            // Increase difficulty gradually
            if (game.frameCount % 900 === 0) {
                game.speed = Math.min(game.speed + 0.3, 9);
            }

            // Spawn basement entrance when reaching shop milestone
            if (game.score >= game.nextShopScore && !game.basementSpawned && basementEntrances.length === 0) {
                basementEntrances.push({
                    x: canvas.width + 200, // Spawn ahead on screen
                    y: 390, // Ground level
                    width: 120,
                    height: 110,
                    triggered: false, // Track if cutscene was triggered
                    enteringBasement: false // Track if pig is entering
                });
                game.basementSpawned = true; // Mark as spawned for this milestone
            }

            // Update piggy banks
            for (let i = piggyBanks.length - 1; i >= 0; i--) {
                piggyBanks[i].x -= game.speed;

                if (!piggyBanks[i].broken) {
                    // Check bullet collision with piggy bank (adjusted for MASSIVE size and centered position)
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const platformY = piggyBanks[i].y - 15;
                        const pigX = piggyBanks[i].x + piggyBanks[i].width/2 - 50; // Centered
                        const pigY = platformY - 55;

                        // Much larger hitbox for piggy bank
                        if (bullets[j].x >= pigX &&
                            bullets[j].x <= pigX + 100 &&
                            bullets[j].y >= pigY &&
                            bullets[j].y <= pigY + 76) {

                            // Break piggy bank!
                            piggyBanks[i].broken = true;
                            game.money += 100;
                            bullets.splice(j, 1);
                            break;
                        }
                    }

                    // Check if player lands on the platform (FULL WIDTH platform on top of building)
                    const playerBottom = player.isCrouching ? player.y + 65 : player.y + 62;
                    const platformY = piggyBanks[i].y - 15; // Platform is 15px above building
                    const platformX = piggyBanks[i].x; // Full width
                    const platformWidth = piggyBanks[i].width; // ENTIRE BUILDING WIDTH

                    if (player.x + 50 > platformX &&
                        player.x < platformX + platformWidth &&
                        playerBottom >= platformY &&
                        playerBottom <= platformY + 15 &&
                        player.velocityY > 0) {

                        // Can stand on platform
                        player.y = platformY - 62 + (player.isCrouching ? 15 : 0);
                        player.velocityY = 0;
                        player.isJumping = false;
                    }
                }

                // Remove off-screen piggy banks
                if (piggyBanks[i].x < -piggyBanks[i].width) {
                    piggyBanks.splice(i, 1);
                }
            }

            // Update street lamps
            for (let i = streetLamps.length - 1; i >= 0; i--) {
                streetLamps[i].x -= game.speed;

                // Remove if off-screen
                if (streetLamps[i].x < -streetLamps[i].width) {
                    streetLamps.splice(i, 1);
                }
            }

            // Update basement entrances
            for (let i = basementEntrances.length - 1; i >= 0; i--) {
                const entrance = basementEntrances[i];
                entrance.x -= game.speed;

                // Check if basement is approaching (within 300px)
                if (!entrance.triggered && entrance.x <= player.x + 300) {
                    entrance.triggered = true;
                    entrance.enteringBasement = true;
                    game.autoRunning = true; // Disable player control
                }

                // If pig is entering basement, move pig towards entrance
                if (entrance.enteringBasement) {
                    // Move pig right automatically
                    player.x += 3;

                    // When pig reaches the entrance center, open shop
                    if (player.x >= entrance.x + entrance.width / 2) {
                        game.running = false;
                        game.autoRunning = false;
                        openShop();
                        basementEntrances.splice(i, 1);
                        continue;
                    }
                }

                // Remove if off-screen
                if (entrance.x < -entrance.width) {
                    basementEntrances.splice(i, 1);
                }
            }

            // Update UI
            updateUI();
        }

        // Draw game
        function draw() {
            drawBackground();

            // Draw bullets (brighter and more visible)
            bullets.forEach(bullet => {
                // Outer glow
                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.fillRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);

                // Main bullet
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

                // White core
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(bullet.x + 1, bullet.y + 1, Math.max(1, bullet.width - 2), Math.max(1, bullet.height - 2));
            });

            // Draw enemies
            enemies.forEach(drawEnemy);

            // Draw obstacles
            obstacles.forEach(drawObstacle);

            // Draw basement entrances
            basementEntrances.forEach(drawBasementEntrance);

            // Draw street lamps
            streetLamps.forEach(drawStreetLamp);

            // Draw dropped barrels
            droppedBarrels.forEach(barrel => {
                if (barrel.exploding) {
                    // Explosion animation
                    const explosionProgress = 1 - (barrel.explosionTimer / 30);
                    const explosionSize = 40 * explosionProgress;

                    // Orange explosion
                    ctx.fillStyle = `rgba(255, 140, 0, ${1 - explosionProgress})`;
                    ctx.fillRect(
                        barrel.x - explosionSize / 2,
                        barrel.y - explosionSize / 2,
                        barrel.width + explosionSize,
                        barrel.height + explosionSize
                    );

                    // Yellow inner explosion
                    ctx.fillStyle = `rgba(255, 215, 0, ${1 - explosionProgress})`;
                    ctx.fillRect(
                        barrel.x - explosionSize / 4,
                        barrel.y - explosionSize / 4,
                        barrel.width + explosionSize / 2,
                        barrel.height + explosionSize / 2
                    );

                    // White core
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - explosionProgress})`;
                    ctx.fillRect(
                        barrel.x + barrel.width / 4,
                        barrel.y + barrel.height / 4,
                        barrel.width / 2,
                        barrel.height / 2
                    );
                } else {
                    // Draw falling barrel (explosive, red)
                    ctx.fillStyle = '#8B0000'; // Dark red
                    ctx.fillRect(barrel.x, barrel.y, barrel.width, barrel.height);

                    // Top/bottom bands
                    ctx.fillStyle = '#CD853F';
                    ctx.fillRect(barrel.x, barrel.y, barrel.width, 4);
                    ctx.fillRect(barrel.x, barrel.y + barrel.height - 4, barrel.width, 4);

                    // Warning symbol (!)
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(barrel.x + barrel.width / 2 - 2, barrel.y + 8, 4, 8);
                    ctx.fillRect(barrel.x + barrel.width / 2 - 2, barrel.y + 18, 4, 3);
                }
            });

            // Draw piggy banks (buildings are now in background, only platform and pig are interactive)
            piggyBanks.forEach(bank => {
                // Draw building in background (semi-transparent, passable) - HUGE, DARK GRAY COLORS
                ctx.globalAlpha = 0.5;

                // Main building body (dark gray)
                ctx.fillStyle = '#3A3A3A'; // Dark gray
                ctx.fillRect(bank.x, bank.y, bank.width, bank.height);

                // Building sections/pillars (more pillars for massive building)
                ctx.fillStyle = '#4A4A4A'; // Slightly lighter gray for pillars
                ctx.fillRect(bank.x, bank.y, 20, bank.height);
                ctx.fillRect(bank.x + bank.width/4 - 10, bank.y, 20, bank.height);
                ctx.fillRect(bank.x + bank.width/2 - 10, bank.y, 20, bank.height);
                ctx.fillRect(bank.x + 3*bank.width/4 - 10, bank.y, 20, bank.height);
                ctx.fillRect(bank.x + bank.width - 20, bank.y, 20, bank.height);

                // Door sections (5 doors for massive building)
                ctx.fillStyle = '#2A2A2A'; // Very dark gray for doors
                const doorWidth = 50;
                const doorHeight = 70;
                for (let i = 0; i < 5; i++) {
                    const doorX = bank.x + 60 + i * (bank.width - 120) / 4;
                    ctx.fillRect(doorX, bank.y + bank.height - doorHeight, doorWidth, doorHeight);
                }

                // Roof detail (dark gray, bigger)
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(bank.x - 10, bank.y - 10, bank.width + 20, 20);

                // Windows - MANY windows for massive building (golden glow)
                ctx.fillStyle = '#FFD700';
                const windowSize = 18;
                const windowSpacing = 35;
                const windowsPerRow = Math.floor((bank.width - 40) / windowSpacing);

                // Multiple rows of windows (5 rows for taller building)
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < windowsPerRow; col++) {
                        const wx = bank.x + 25 + col * windowSpacing;
                        const wy = bank.y + 30 + row * 35;

                        // Skip windows where doors are (only bottom 2 rows)
                        if (row < 3) {
                            ctx.fillRect(wx, wy, windowSize, windowSize);
                        } else {
                            // Check if not in door area
                            let isInDoorArea = false;
                            for (let i = 0; i < 5; i++) {
                                const doorX = bank.x + 60 + i * (bank.width - 120) / 4;
                                if (wx > doorX - 10 && wx < doorX + doorWidth + 10) {
                                    isInDoorArea = true;
                                    break;
                                }
                            }
                            if (!isInDoorArea) {
                                ctx.fillRect(wx, wy, windowSize, windowSize);
                            }
                        }
                    }
                }

                // Bank sign (bigger and more prominent)
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 32px Courier New';
                ctx.fillText('PIGGY BANK', bank.x + bank.width/2 - 95, bank.y + 25);

                ctx.globalAlpha = 1.0;

                // Draw platform on top (solid, can stand on it) - FULL WIDTH OF BUILDING
                const platformY = bank.y - 15;
                const platformX = bank.x;
                const platformWidth = bank.width; // ENTIRE BUILDING WIDTH

                ctx.fillStyle = '#3A3A3A'; // Dark gray platform to match building
                ctx.fillRect(platformX, platformY, platformWidth, 15);
                ctx.strokeStyle = '#2A2A2A';
                ctx.lineWidth = 4;
                ctx.strokeRect(platformX, platformY, platformWidth, 15);

                // Platform edge details (railings)
                ctx.fillStyle = '#4A4A4A';
                for (let i = 0; i < platformWidth; i += 40) {
                    ctx.fillRect(platformX + i, platformY, 5, 15);
                }

                if (!bank.broken) {
                    // Piggy bank on platform - MUCH BIGGER
                    const pigX = bank.x + bank.width/2 - 50; // Centered
                    const pigY = platformY - 55;

                    // Body (much bigger)
                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(pigX, pigY + 20, 70, 45);

                    // Head (much bigger)
                    ctx.fillRect(pigX + 50, pigY + 10, 35, 35);

                    // Snout (much bigger)
                    ctx.fillStyle = '#FF69B4';
                    ctx.fillRect(pigX + 78, pigY + 22, 14, 14);

                    // Coin slot (much bigger)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pigX + 25, pigY + 15, 28, 6);

                    // Legs (much bigger)
                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(pigX + 12, pigY + 62, 14, 14);
                    ctx.fillRect(pigX + 35, pigY + 62, 14, 14);
                    ctx.fillRect(pigX + 58, pigY + 62, 14, 14);

                    // $ symbol (much bigger and more prominent)
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 32px Courier New';
                    ctx.fillText('$100', pigX + 12, pigY + 50);

                    // Glow effect around piggy bank
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pigX - 5, pigY + 5, 100, 80);
                    ctx.globalAlpha = 1.0;
                } else {
                    // Broken piggy bank pieces (much bigger)
                    const pigX = bank.x + bank.width/2 - 50;
                    const pigY = platformY - 55;

                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(pigX + 14, pigY + 35, 25, 20);
                    ctx.fillRect(pigX + 50, pigY + 42, 28, 25);
                    ctx.fillRect(pigX + 25, pigY + 55, 20, 16);

                    // Coins scattered (much bigger)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pigX + 20, pigY + 45, 12, 12);
                    ctx.fillRect(pigX + 45, pigY + 52, 12, 12);
                    ctx.fillRect(pigX + 63, pigY + 50, 12, 12);
                }
            });

            // Draw player
            drawPig();

            // Shop warning when close to milestone (no yellow filter)
            const scoreUntilShop = game.nextShopScore - game.score;
            if (scoreUntilShop <= 100 && scoreUntilShop > 0) {
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 40px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText('üè™ SHOP NEARBY! üè™', canvas.width / 2, 80);
                ctx.fillText('üè™ SHOP NEARBY! üè™', canvas.width / 2, 80);
                ctx.font = 'bold 25px Courier New';
                ctx.fillStyle = '#FFD700';
                ctx.strokeText(`${scoreUntilShop} points left`, canvas.width / 2, 130);
                ctx.fillText(`${scoreUntilShop} points left`, canvas.width / 2, 130);
            }

            // Countdown timer
            if (game.countdown > 0) {
                const countNum = Math.ceil(game.countdown / 60);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 120px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 5;
                ctx.strokeText(countNum, canvas.width / 2, canvas.height / 2);
                ctx.fillText(countNum, canvas.width / 2, canvas.height / 2);
            }

            // Reload indicator
            if (game.isReloading) {
                const reloadPercent = (weapons[game.weapon].reloadTime - game.reloadProgress) / weapons[game.weapon].reloadTime;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 150, canvas.height - 80, 300, 40);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(canvas.width / 2 - 145, canvas.height - 75, 290 * reloadPercent, 30);
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('RELOADING...', canvas.width / 2, canvas.height - 52);
            }

            // Pump indicator (shotgun)
            if (game.isPumping) {
                ctx.fillStyle = '#FFA500';
                ctx.font = 'bold 30px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText('PUMPING!', canvas.width / 2, canvas.height / 2);
                ctx.fillText('PUMPING!', canvas.width / 2, canvas.height / 2);
            }

            // Draw cutscene if active
            if (game.cutsceneActive) {
                drawBasement();

                // Always draw counters in basement
                drawShopCounter(shopCounters.weapons);
                drawShopCounter(shopCounters.equipment);
                drawShopCounter(shopCounters.boosts);

                // Always draw merchant on right side (behind counters)
                drawMerchant(canvas.width - 150, 240);

                // Draw pig with proper model
                if (game.cutscenePhase === 0) {
                    // Pig running in from left
                    const tempPlayerX = player.x;
                    const tempPlayerY = player.y;
                    player.x = game.pigX;
                    player.y = 380;

                    drawPig(); // Use actual pig drawing function

                    player.x = tempPlayerX;
                    player.y = tempPlayerY;

                    // Show "Entering basement..." text
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 30px Courier New';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.strokeText('Entering basement...', canvas.width / 2, 50);
                    ctx.fillText('Entering basement...', canvas.width / 2, 50);
                } else if (game.cutscenePhase === 1) {
                    // Pig standing in front (dialog phase) - position to not block counters
                    const tempPlayerX = player.x;
                    const tempPlayerY = player.y;
                    player.x = 70;  // Far left, not blocking counters
                    player.y = 380;

                    drawPig(); // Use actual pig drawing function

                    player.x = tempPlayerX;
                    player.y = tempPlayerY;
                } else if (game.cutscenePhase === 2) {
                    // Shop phase - draw items on counters (without tooltips first)
                    shopCounters.weapons.items.forEach(item => {
                        const isHovered = game.hoveredItem && game.hoveredItem.id === item.id;
                        drawWeaponOnCounter(item.id, item.x, item.y, item.width, item.height, isHovered);
                    });

                    shopCounters.equipment.items.forEach(item => {
                        const isHovered = game.hoveredItem && game.hoveredItem.id === item.id;
                        drawArmorOnCounter(item.x, item.y, item.width, item.height, isHovered);
                    });

                    shopCounters.boosts.items.forEach(item => {
                        const isHovered = game.hoveredItem && game.hoveredItem.id === item.id;
                        drawHealthOnCounter(item.x, item.y, item.width, item.height, isHovered);
                    });

                    // Draw pig in front left (not blocking counters)
                    const tempPlayerX = player.x;
                    const tempPlayerY = player.y;
                    player.x = 40;  // Very far left
                    player.y = 380;
                    drawPig();
                    player.x = tempPlayerX;
                    player.y = tempPlayerY;

                    // Draw tooltip LAST so it appears on top of everything
                    if (game.hoveredItem) {
                        drawItemTooltip(game.hoveredItem, game.hoveredItem.x, game.hoveredItem.y);
                    }

                    // Draw instructions
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('Hover items to see details | Click to buy | ESC to exit', canvas.width / 2, 50);
                    ctx.fillText(`Money: $${game.money}`, canvas.width / 2, 490);
                }
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('money').textContent = game.money;
            document.getElementById('health').textContent = game.health;
            document.getElementById('weapon').textContent = weapons[game.weapon].name;
            document.getElementById('level').textContent = game.level + 1;
            document.getElementById('nextShop').textContent = game.nextShopScore;
            document.getElementById('armor').textContent = game.armor;

            // Show/hide armor display based on whether player has armor
            const armorDisplay = document.getElementById('armorDisplay');
            if (game.armor > 0) {
                armorDisplay.style.display = 'inline';
            } else {
                armorDisplay.style.display = 'none';
            }

            // Update ammo display
            const weapon = weapons[game.weapon];
            const ammoDisplay = document.getElementById('ammo');
            if (game.isReloading) {
                ammoDisplay.textContent = 'RELOADING...';
                ammoDisplay.style.color = '#FF6B6B';
            } else if (game.isPumping) {
                ammoDisplay.textContent = 'PUMPING...';
                ammoDisplay.style.color = '#FFA500';
            } else {
                ammoDisplay.textContent = `${game.currentAmmo}/${weapon.magSize}`;
                ammoDisplay.style.color = game.currentAmmo === 0 ? '#FF0000' : '#FFD700';
            }
        }

        // Game over
        function gameOver() {
            game.running = false;

            // Save game statistics
            GameStats.saveAttempt(game.score, game.money, game.level, weapons[game.weapon].name, game.kills);

            document.getElementById('finalScore').textContent = game.score;
            document.getElementById('finalMoney').textContent = game.money;
            document.getElementById('gameOver').classList.add('active');

            // Stop background music on game over
            stopBackgroundMusic();
        }

        // Start game
        function startGame() {
            game.running = true;
            game.score = 0;
            game.money = 0;
            game.health = 5;
            game.speed = 3;
            game.frameCount = 0;
            game.weapon = 'colt';
            game.currentAmmo = 7;
            game.isReloading = false;
            game.reloadProgress = 0;
            game.isPumping = false;
            game.pumpProgress = 0;
            game.level = 0;
            game.nextShopScore = 500;
            game.ownedWeapons = ['colt'];
            game.lastShot = false;
            game.armor = 0;
            game.maxHealth = 5;
            game.nextPiggyBank = Math.random() * 500;
            game.piggyBankSpawned = false;
            game.kills = 0; // Reset kill counter
            game.helicopterActive = false; // Reset helicopter flag
            game.nextHelicopterScore = 500; // Reset helicopter spawn milestone
            game.nextStreetLampScore = 100; // Reset street lamp spawn milestone
            game.cutsceneActive = false; // Reset cutscene
            game.cutscenePhase = 0;
            game.cutsceneTimer = 0;
            game.pigX = 100;
            game.basementSpawned = false; // Reset basement spawn flag
            game.autoRunning = false; // Reset auto-running flag

            player.y = 440;
            player.velocityY = 0;
            player.isJumping = false;

            bullets.length = 0;
            enemies.length = 0;
            obstacles.length = 0;
            piggyBanks.length = 0;
            droppedBarrels.length = 0; // Clear dropped barrels
            streetLamps.length = 0; // Clear street lamps
            basementEntrances.length = 0; // Clear basement entrances

            document.getElementById('gameOver').classList.remove('active');
            document.getElementById('shop').classList.remove('active');
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('merchantDialog').style.display = 'none';
            updateUI();

            // Start background music
            // playBackgroundMusic(); // Music disabled
        }

        // Shop functions
        function openShop() {
            // Start cutscene instead of directly opening shop
            game.cutsceneActive = true;
            game.cutscenePhase = 0;
            game.cutsceneTimer = 0;
            game.pigX = -50; // Start pig off-screen left for running animation
            game.running = false;

            // Prepare shop for when player accepts
            document.getElementById('shopLevel').textContent = game.level + 1;
            updateShopUI();

            // Pause background music
            stopBackgroundMusic();
        }

        function actuallyOpenShop() {
            // This is called when player accepts merchant's offer
            // Instead of showing HTML shop, stay in cutscene and show counters
            game.cutscenePhase = 2; // Shop phase
            game.inShop = true;
            document.getElementById('merchantDialog').style.display = 'none';
            // Hide UI panel
            document.getElementById('ui').style.display = 'none';
        }

        function closeShop() {
            document.getElementById('shop').classList.remove('active');

            // Move to next level
            game.level++;
            if (game.level < game.shopMilestones.length) {
                game.nextShopScore = game.shopMilestones[game.level];
            } else {
                // After all milestones, add 15000 to each next milestone
                game.nextShopScore += 15000;
            }

            // Reset basement spawned flag for next milestone
            game.basementSpawned = false;

            // Show UI panel again
            document.getElementById('ui').style.display = 'block';

            // Start countdown: 3-2-1
            game.countdown = 180; // 3 seconds at 60fps
            updateUI();
        }

        function buyItemFromCounter(itemId) {
            // Buy item from interactive counter
            if (itemId === 'health') {
                buyItem('health', 50);
            } else if (itemId === 'armor') {
                buyItem('armor', 100);
            } else if (itemId in weapons) {
                const weapon = weapons[itemId];
                buyItem(itemId, weapon.price);
            }
        }

        function buyItem(item, cost) {
            if (item === 'health') {
                if (game.money >= cost && game.health < game.maxHealth) {
                    game.money -= cost;
                    game.health = Math.min(game.health + 1, game.maxHealth); // Only +1 HP now
                    updateUI();
                    updateShopUI();
                }
            } else if (item === 'armor') {
                if (game.money >= cost) {
                    game.money -= cost;
                    game.armor++;
                    updateUI();
                }
            } else {
                // Weapon purchase
                const weapon = item;
                if (!game.ownedWeapons.includes(weapon)) {
                    if (game.money >= cost) {
                        game.money -= cost;
                        game.ownedWeapons.push(weapon);
                        game.weapon = weapon;
                        game.currentAmmo = weapons[weapon].magSize;
                        game.isReloading = false;
                        updateUI();
                        updateShopUI();
                    }
                } else {
                    // Already owned - just switch to it
                    game.weapon = weapon;
                    game.currentAmmo = weapons[weapon].magSize;
                    game.isReloading = false;
                    updateUI();
                }
            }
        }

        function updateShopUI() {
            // Update Health button
            const healthBtn = document.getElementById('buyHealth');
            if (game.health >= game.maxHealth) {
                healthBtn.style.opacity = '0.5';
                healthBtn.querySelector('div:last-child').textContent = 'MAX HEALTH REACHED';
            } else {
                healthBtn.style.opacity = '1';
                healthBtn.querySelector('div:last-child').textContent = 'Price: $50';
            }

            // Update Colt button
            const coltBtn = document.getElementById('buyColt');
            if (game.ownedWeapons.includes('colt')) {
                coltBtn.style.opacity = '0.6';
                coltBtn.querySelector('div:last-child').textContent = game.weapon === 'colt' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            }

            // Update Shotgun button
            const shotgunBtn = document.getElementById('buyShotgun');
            if (game.ownedWeapons.includes('shotgun')) {
                shotgunBtn.style.opacity = '0.6';
                shotgunBtn.querySelector('div:last-child').textContent = game.weapon === 'shotgun' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            } else {
                shotgunBtn.querySelector('div:last-child').textContent = '8 rounds | Damage: 3x5 | Price: $200';
            }

            // Update Sniper button
            const sniperBtn = document.getElementById('buySniper');
            if (game.ownedWeapons.includes('sniper')) {
                sniperBtn.style.opacity = '0.6';
                sniperBtn.querySelector('div:last-child').textContent = game.weapon === 'sniper' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            } else {
                sniperBtn.querySelector('div:last-child').textContent = '5 rounds | Damage: 10 | Price: $300';
            }

            // Update Tommy button
            const tommyBtn = document.getElementById('buyTommy');
            if (game.ownedWeapons.includes('tommy')) {
                tommyBtn.style.opacity = '0.6';
                tommyBtn.querySelector('div:last-child').textContent = game.weapon === 'tommy' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            } else {
                tommyBtn.querySelector('div:last-child').textContent = '50 rounds | Damage: 1 | Price: $350';
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            // Handle ESC in shop
            if (e.key === 'Escape' && game.inShop && game.cutscenePhase === 2) {
                game.inShop = false;
                game.cutsceneActive = false;
                game.hoveredItem = null;
                closeShop();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;

            // Handle shop clicks
            if (game.inShop && game.cutscenePhase === 2) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Check if clicked on any item
                const allItems = [
                    ...shopCounters.weapons.items,
                    ...shopCounters.equipment.items,
                    ...shopCounters.boosts.items
                ];

                for (const item of allItems) {
                    if (mouseX >= item.x && mouseX <= item.x + item.width &&
                        mouseY >= item.y && mouseY <= item.y + item.height) {
                        // Buy item
                        buyItemFromCounter(item.id);
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => mouseDown = false);

        canvas.addEventListener('mousemove', (e) => {
            if (game.inShop && game.cutscenePhase === 2) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                game.mouseX = mouseX;
                game.mouseY = mouseY;

                // Check hover on items
                game.hoveredItem = null;

                const allItems = [
                    ...shopCounters.weapons.items,
                    ...shopCounters.equipment.items,
                    ...shopCounters.boosts.items
                ];

                for (const item of allItems) {
                    if (mouseX >= item.x && mouseX <= item.x + item.width &&
                        mouseY >= item.y && mouseY <= item.y + item.height) {
                        game.hoveredItem = item;
                        canvas.style.cursor = 'pointer';
                        break;
                    }
                }

                if (!game.hoveredItem) {
                    canvas.style.cursor = 'default';
                }
            } else {
                canvas.style.cursor = 'default';
            }
        });

        // Merchant dialog event listeners
        document.getElementById('acceptShop').addEventListener('click', () => {
            actuallyOpenShop();
        });

        document.getElementById('declineShop').addEventListener('click', () => {
            // Close dialog and skip shop
            document.getElementById('merchantDialog').style.display = 'none';
            game.cutsceneActive = false;
            closeShop(); // Continue to next level
        });

        document.getElementById('closeShop').addEventListener('click', closeShop);

        document.getElementById('buyHealth').addEventListener('click', () => {
            buyItem('health', 50);
        });

        document.getElementById('buyArmor').addEventListener('click', () => {
            buyItem('armor', 100);
        });

        document.getElementById('buyColt').addEventListener('click', () => {
            buyItem('colt', 0);
        });

        document.getElementById('buyShotgun').addEventListener('click', () => {
            buyItem('shotgun', 200);
        });

        document.getElementById('buySniper').addEventListener('click', () => {
            buyItem('sniper', 300);
        });

        document.getElementById('buyTommy').addEventListener('click', () => {
            buyItem('tommy', 350);
        });

        document.getElementById('restart').addEventListener('click', startGame);

        document.getElementById('mainMenuButton').addEventListener('click', () => {
            document.getElementById('gameOver').classList.remove('active');
            document.getElementById('mainMenu').classList.remove('hidden');
            game.running = false;
        });

        // Main Menu event listeners
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('mainMenu').classList.add('hidden');
            startGame();
        });

        document.getElementById('settingsButton').addEventListener('click', () => {
            document.getElementById('settingsMenu').classList.add('active');
        });

        document.getElementById('closeSettings').addEventListener('click', () => {
            document.getElementById('settingsMenu').classList.remove('active');
        });

        // Statistics button
        document.getElementById('statsButton').addEventListener('click', () => {
            openStatsMenu();
        });

        document.getElementById('closeStats').addEventListener('click', () => {
            document.getElementById('statsMenu').classList.remove('active');
        });

        document.getElementById('clearStats').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all statistics? This cannot be undone!')) {
                GameStats.clearStats();
                openStatsMenu(); // Refresh the stats display
            }
        });

        // Function to open and populate stats menu
        function openStatsMenu() {
            const stats = GameStats.loadStats();

            // Update overall stats
            document.getElementById('bestScore').textContent = GameStats.getBestScore();
            document.getElementById('totalGames').textContent = GameStats.getTotalGames();
            document.getElementById('totalMoney').textContent = '$' + GameStats.getTotalMoney();

            // Calculate total kills
            const totalKills = stats.reduce((sum, s) => sum + (s.kills || 0), 0);
            document.getElementById('totalKills').textContent = totalKills;

            // Display recent games
            const recentGamesDiv = document.getElementById('recentGames');
            if (stats.length === 0) {
                recentGamesDiv.innerHTML = '<div style="text-align: center; color: #FFB6C1; padding: 20px;">No games played yet. Start playing to see your stats!</div>';
            } else {
                // Sort by timestamp (newest first)
                const sortedStats = [...stats].sort((a, b) => b.timestamp - a.timestamp);

                recentGamesDiv.innerHTML = sortedStats.map(attempt => `
                    <div class="stats-game-item">
                        <div>
                            <div class="stat-label">Date</div>
                            <div class="stat-value" style="font-size: 12px;">${attempt.date}</div>
                        </div>
                        <div>
                            <div class="stat-label">Score</div>
                            <div class="stat-value">${attempt.score}</div>
                        </div>
                        <div>
                            <div class="stat-label">Money</div>
                            <div class="stat-value">$${attempt.money}</div>
                        </div>
                        <div>
                            <div class="stat-label">Kills</div>
                            <div class="stat-value">${attempt.kills || 0}</div>
                        </div>
                    </div>
                `).join('');
            }

            document.getElementById('statsMenu').classList.add('active');
        }

        // Volume control
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');

        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value;
            game.volume = volume / 100; // Convert to 0.0 - 1.0
            volumeValue.textContent = volume + '%';

            // Update background music volume
            updateMusicVolume();

            // Restart music if it was stopped due to muted volume
            // if (game.volume > 0 && !musicPlaying && game.running) {
            //     playBackgroundMusic(); // Music disabled
            // }
        });

        // Shop tab switching
        const shopTabs = document.querySelectorAll('.shop-tab');
        const shopContents = document.querySelectorAll('.shop-content');

        shopTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                shopTabs.forEach(t => t.classList.remove('active'));
                shopContents.forEach(c => c.classList.remove('active'));

                // Add active class to clicked tab
                tab.classList.add('active');

                // Show corresponding content
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(tabName + '-content').classList.add('active');
            });
        });

        // Initialize and start
        initBuildings();
        gameLoop();

        // Don't auto-start game, wait for menu interaction
        // startGame(); // Removed - game starts from menu now
    </script>
</body>
</html>
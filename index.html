<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIGGY'S REVENGE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.5), 0 10px 50px rgba(0, 0, 0, 0.8);
            border: 4px solid #FF1493;
        }

        #gameCanvas {
            display: block;
            background: #87CEEB;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #FF1493;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 10px rgba(255, 20, 147, 0.8);
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border: 3px solid #FF1493;
            box-shadow: inset 0 0 20px rgba(255, 20, 147, 0.3);
            image-rendering: pixelated;
        }

        #ui > div {
            margin: 8px 0;
            letter-spacing: 1px;
        }

        #ui span {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            padding: 30px;
            border: 5px solid #FF1493;
            display: none;
            z-index: 100;
            color: #FF1493;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), inset 0 0 30px rgba(255, 20, 147, 0.2);
            image-rendering: pixelated;
        }

        #shop.active {
            display: block;
        }

        #shop h2 {
            text-shadow: 3px 3px 0px #000000, 0 0 20px #FF1493;
            color: #FF1493;
        }

        #shop h3 {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        .shop-item {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 20, 147, 0.1);
            border: 3px solid #FF1493;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.2);
        }

        .shop-item:hover {
            background: rgba(255, 20, 147, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.8), inset 0 0 20px rgba(255, 20, 147, 0.4);
        }

        .shop-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-item.disabled:hover {
            transform: none;
            background: rgba(255, 20, 147, 0.1);
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.2);
        }

        .shop-item strong {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        .shop-item div {
            color: #FF69B4;
        }

        .shop-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .shop-tab {
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            color: #FFB6C1;
            background: rgba(255, 20, 147, 0.1);
            border: 3px solid #FF1493;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.2);
            font-family: 'Courier New', monospace;
        }

        .shop-tab:hover {
            background: rgba(255, 20, 147, 0.2);
            transform: scale(1.05);
        }

        .shop-tab.active {
            background: rgba(255, 20, 147, 0.4);
            color: #FF1493;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6), inset 0 0 20px rgba(255, 20, 147, 0.4);
        }

        .shop-content {
            display: none;
        }

        .shop-content.active {
            display: block;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            padding: 40px;
            border: 5px solid #FF1493;
            display: none;
            text-align: center;
            color: #FF1493;
            z-index: 100;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), inset 0 0 30px rgba(255, 20, 147, 0.2);
            image-rendering: pixelated;
        }

        #gameOver.active {
            display: block;
        }

        #gameOver h1 {
            color: #FF1493;
            text-shadow: 3px 3px 0px #000000, 0 0 20px #FF1493;
        }

        #gameOver h2, #gameOver h3 {
            color: #FFB6C1;
            text-shadow: 2px 2px 0px #000000;
        }

        button {
            margin: 10px;
            padding: 15px 35px;
            font-size: 20px;
            cursor: pointer;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            border: 3px solid #FF1493;
            font-weight: bold;
            transition: all 0.2s;
            color: #000000;
            text-shadow: 1px 1px 0px rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.5);
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
        }

        button:hover {
            background: linear-gradient(135deg, #FF69B4 0%, #FF1493 100%);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        }

        button:active {
            transform: scale(1.05);
        }

        .controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #FF1493;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 10px rgba(255, 20, 147, 0.8);
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border: 3px solid #FF1493;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.3);
        }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 20, 147, 0.03) 2px, rgba(255, 20, 147, 0.03) 4px),
                linear-gradient(135deg, #000000 0%, #1a0a1a 50%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            image-rendering: pixelated;
            box-shadow: inset 0 0 100px rgba(255, 20, 147, 0.1);
        }

        #mainMenu.hidden {
            display: none;
        }

        .menu-logo {
            width: 260px;
            height: 260px;
            margin-top: 40px;
            margin-bottom: 30px;
            filter: drop-shadow(0 0 30px #FF1493) drop-shadow(0 0 50px #FF1493);
            animation: logoFloat 3s ease-in-out infinite;
            image-rendering: pixelated;
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
        }

        .menu-title {
            font-size: 72px;
            font-weight: bold;
            color: #FF1493;
            text-shadow: 4px 4px 0px #000000, 0 0 30px #FF1493, 0 0 50px #FF1493;
            margin-bottom: 60px;
            animation: pulse 2s infinite, glitch 5s infinite;
            letter-spacing: 5px;
            position: relative;
        }

        @keyframes glitch {
            0%, 90%, 100% { text-shadow: 4px 4px 0px #000000, 0 0 30px #FF1493, 0 0 50px #FF1493; }
            92% { text-shadow: 4px 4px 0px #000000, -2px 0 #FF1493, 2px 0 #00FFFF; }
            94% { text-shadow: 4px 4px 0px #000000, 2px 0 #FF1493, -2px 0 #00FFFF; }
        }

        .menu-subtitle {
            font-size: 28px;
            color: #FFB6C1;
            text-shadow: 3px 3px 0px #000000, 0 0 15px #FFB6C1;
            margin-bottom: 60px;
            font-weight: bold;
            letter-spacing: 3px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .menu-button {
            width: 320px;
            padding: 20px 40px;
            margin: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #000000;
            background: linear-gradient(180deg, #FF1493 0%, #FF69B4 50%, #FF1493 100%);
            border: 5px solid #FF1493;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 25px rgba(255, 20, 147, 0.6), 0 5px 0px #8B0045, inset 0 0 20px rgba(255, 255, 255, 0.2);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
            letter-spacing: 3px;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            position: relative;
            top: 0;
        }

        .menu-button:hover {
            transform: scale(1.08);
            box-shadow: 0 0 45px rgba(255, 20, 147, 0.9), 0 5px 0px #8B0045, inset 0 0 30px rgba(255, 255, 255, 0.3);
            background: linear-gradient(180deg, #FF69B4 0%, #FF1493 50%, #FF69B4 100%);
            top: -2px;
        }

        .menu-button:active {
            transform: scale(1.05);
            top: 3px;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6), 0 2px 0px #8B0045, inset 0 0 15px rgba(255, 255, 255, 0.2);
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a0a1a 0%, #2a0a2a 100%);
            padding: 50px;
            border-radius: 20px;
            border: 4px solid #FF1493;
            display: none;
            z-index: 300;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), 0 10px 30px rgba(0, 0, 0, 0.8);
        }

        #settingsMenu.active {
            display: block;
        }

        #statsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a0a1a 0%, #2a0a2a 100%);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #FF1493;
            display: none;
            z-index: 300;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.6), 0 10px 30px rgba(0, 0, 0, 0.8);
            min-width: 600px;
            max-width: 800px;
        }

        #statsMenu.active {
            display: block;
        }

        .stats-game-item {
            background: rgba(255, 20, 147, 0.05);
            border: 2px solid #FF1493;
            padding: 12px;
            margin: 10px 0;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 10px;
            transition: all 0.2s;
        }

        .stats-game-item:hover {
            background: rgba(255, 20, 147, 0.15);
            transform: translateX(5px);
        }

        .stats-game-item .stat-label {
            color: #FFB6C1;
            font-size: 12px;
        }

        .stats-game-item .stat-value {
            color: #FF1493;
            font-weight: bold;
            font-size: 16px;
        }

        #statsContent::-webkit-scrollbar {
            width: 10px;
        }

        #statsContent::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        #statsContent::-webkit-scrollbar-thumb {
            background: #FF1493;
            border-radius: 10px;
        }

        #statsContent::-webkit-scrollbar-thumb:hover {
            background: #FF69B4;
        }

        .settings-title {
            font-size: 42px;
            font-weight: bold;
            color: #FF1493;
            text-align: center;
            margin-bottom: 40px;
            text-shadow: 3px 3px 0px #000000, 0 0 20px #FF1493;
            letter-spacing: 2px;
        }

        .setting-item {
            margin: 30px 0;
        }

        .setting-label {
            font-size: 24px;
            color: #FFB6C1;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0px #000000;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .volume-slider {
            width: 300px;
            height: 15px;
            -webkit-appearance: none;
            appearance: none;
            background: #1a1a1a;
            outline: none;
            border: 3px solid #FF1493;
            box-shadow: inset 0 0 10px rgba(255, 20, 147, 0.3);
            image-rendering: pixelated;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 30px;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            cursor: pointer;
            border: 2px solid #FF1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.9);
            image-rendering: pixelated;
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 30px;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            cursor: pointer;
            border: 2px solid #FF1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.9);
            image-rendering: pixelated;
        }

        .volume-value {
            font-size: 24px;
            color: #FF1493;
            font-weight: bold;
            min-width: 60px;
            text-shadow: 2px 2px 0px #000000, 0 0 15px #FF1493;
            letter-spacing: 2px;
        }

        .settings-button {
            width: 200px;
            padding: 15px 30px;
            margin: 20px auto 0;
            display: block;
            font-size: 22px;
            font-weight: bold;
            color: #000000;
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            border: 3px solid #FF1493;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.5);
        }

        .settings-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>

        <!-- Main Menu -->
        <div id="mainMenu">
            <!-- Logo SVG -->
            <svg class="menu-logo" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                <!-- Outer circle -->
                <circle cx="100" cy="100" r="95" fill="#FF1493" stroke="none"/>
                <!-- Inner circle (black) -->
                <circle cx="100" cy="100" r="85" fill="#000000" stroke="none"/>
                <!-- Smile curve -->
                <path d="M 45 90 Q 100 140 155 90" stroke="#FF1493" stroke-width="20" fill="none" stroke-linecap="round"/>
                <!-- Dot below smile -->
                <circle cx="100" cy="155" r="12" fill="#FF1493"/>
            </svg>

            <h1 class="menu-title">PIGGY'S REVENGE</h1>
            <button class="menu-button" id="startButton">START GAME</button>
            <button class="menu-button" id="statsButton">STATISTICS</button>
            <button class="menu-button" id="settingsButton">SETTINGS</button>
        </div>

        <!-- Settings Menu -->
        <div id="settingsMenu">
            <h2 class="settings-title">SETTINGS</h2>
            <div class="setting-item">
                <div class="setting-label">Sound Effects Volume</div>
                <div class="volume-control">
                    <input type="range" min="0" max="100" value="10" class="volume-slider" id="volumeSlider">
                    <span class="volume-value" id="volumeValue">10%</span>
                </div>
            </div>
            <div class="setting-item">
                <div class="setting-label">Music Volume</div>
                <div class="volume-control">
                    <input type="range" min="0" max="100" value="10" class="volume-slider" id="musicVolumeSlider">
                    <span class="volume-value" id="musicVolumeValue">10%</span>
                </div>
            </div>
            <div class="setting-item">
                <div class="setting-label">Music</div>
                <div style="display: flex; gap: 10px;">
                    <button class="settings-button" id="musicToggle" style="flex: 1; padding: 10px;">ON</button>
                </div>
            </div>
            <button class="settings-button" id="closeSettings">BACK</button>
        </div>

        <!-- Statistics Menu -->
        <div id="statsMenu">
            <h2 class="settings-title">STATISTICS</h2>
            <div id="statsContent" style="max-height: 500px; overflow-y: auto; margin: 20px 0;">
                <div style="margin-bottom: 30px;">
                    <h3 style="color: #FFB6C1; text-align: center; margin-bottom: 20px;">Overall Stats</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Best Score</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="bestScore">0</div>
                        </div>
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Total Games</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="totalGames">0</div>
                        </div>
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Total Money</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="totalMoney">$0</div>
                        </div>
                        <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border: 2px solid #FF1493;">
                            <div style="font-size: 16px; color: #FFB6C1;">Total Kills</div>
                            <div style="font-size: 32px; color: #FF1493; font-weight: bold;" id="totalKills">0</div>
                        </div>
                    </div>
                </div>
                <h3 style="color: #FFB6C1; text-align: center; margin: 20px 0;">Recent Games</h3>
                <div id="recentGames" style="font-size: 14px;">
                    <!-- Recent games will be inserted here -->
                </div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="settings-button" id="clearStats" style="background: linear-gradient(135deg, #DC143C 0%, #FF1493 100%);">CLEAR ALL</button>
                <button class="settings-button" id="closeStats">BACK</button>
            </div>
        </div>

        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Money: $<span id="money">0</span></div>
            <div>Health: <span id="health">5</span>‚ù§Ô∏è <span id="armorDisplay" style="display: none;">| Armor: <span id="armor">0</span>üõ°Ô∏è</span></div>
            <div>Weapon: <span id="weapon">Colt M1911</span></div>
            <div style="font-size: 24px; font-weight: bold; color: #FFD700;">Ammo: <span id="ammo">7/7</span></div>
            <div>Level: <span id="level">1</span> | Next Shop: <span id="nextShop">500</span></div>
        </div>

        <div class="controls">
            <div>‚¨ÜÔ∏è Space - Jump | üî´ Click - Shoot | üîÑ R - Reload</div>
        </div>

        <!-- Cutscene overlay for basement scene -->
        <div id="cutscene" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 150;">
        </div>

        <!-- Merchant dialog (positioned near merchant on right side) -->
        <div id="merchantDialog" style="display: none; position: absolute; top: 28%; right: 18%; transform: translateY(-50%); background: #1a1a1a; padding: 25px; border: 5px solid #FFD700; z-index: 200; color: #FFD700; text-align: left; box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); max-width: 420px;">
            <!-- Speech bubble triangle pointing to merchant (right side) -->
            <div style="position: absolute; right: -20px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 20px solid #FFD700; border-top: 15px solid transparent; border-bottom: 15px solid transparent;"></div>
            <div style="position: absolute; right: -15px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 15px solid #1a1a1a; border-top: 12px solid transparent; border-bottom: 12px solid transparent;"></div>

            <h2 style="margin-bottom: 15px; text-shadow: 2px 2px 0px #000000; font-size: 24px;">üë§ Crouton</h2>
            <p style="font-size: 16px; margin-bottom: 25px; color: #FFF; line-height: 1.5;">Looking for supplies, friend?<br>I have everything you need...</p>
            <div style="text-align: center; display: flex; flex-direction: column; gap: 8px;">
                <button id="acceptShop" style="padding: 12px 30px; font-size: 16px; background: #FFD700; color: #000; border: 3px solid #FFA500; cursor: pointer; font-weight: bold;">Yes, show me</button>
                <button id="declineShop" style="padding: 12px 30px; font-size: 16px; background: #8B0000; color: #FFF; border: 3px solid #FF0000; cursor: pointer; font-weight: bold;">Not now</button>
                <button id="askRestock" style="padding: 12px 30px; font-size: 16px; background: #4169E1; color: #FFF; border: 3px solid #6495ED; cursor: pointer; font-weight: bold;">When will the shop be restocked?</button>
            </div>
        </div>

        <div id="shop">
            <h2 style="text-align: center; margin-bottom: 20px;">üè™ GANGSTER SHOP üè™</h2>
            <h3 style="text-align: center; margin-bottom: 20px;">Level <span id="shopLevel">1</span></h3>

            <!-- Shop Tabs -->
            <div class="shop-tabs">
                <div class="shop-tab active" data-tab="weapons">üî´ WEAPONS</div>
                <div class="shop-tab" data-tab="equipment">üõ°Ô∏è EQUIPMENT</div>
            </div>

            <!-- Weapons Tab -->
            <div class="shop-content active" id="weapons-content">
                <div class="shop-item" id="buyColt">
                    <div><strong>üî´ Colt M1911 (starter)</strong></div>
                    <div>7 rounds | Damage: 2 | You own this ‚úì</div>
                </div>
                <div class="shop-item" id="buyShotgun">
                    <div><strong>üí• Pump Shotgun (power)</strong></div>
                    <div id="shotgunInfo">8 rounds | Damage: 3x5 | Price: $200</div>
                </div>
                <div class="shop-item" id="buySniper">
                    <div><strong>üéØ Sniper Rifle (precision)</strong></div>
                    <div id="sniperInfo">5 rounds | Damage: 5 | Price: $200</div>
                </div>
                <div class="shop-item" id="buyTommy">
                    <div><strong>üî• Tommy Gun (auto)</strong></div>
                    <div id="tommyInfo">50 rounds | Damage: 1 | Price: $350</div>
                </div>
            </div>

            <!-- Equipment Tab -->
            <div class="shop-content" id="equipment-content">
                <div class="shop-item" id="buyArmor">
                    <div><strong>üõ°Ô∏è Armor (+1 protection)</strong></div>
                    <div>Price: $100</div>
                </div>
                <div class="shop-item" id="buyHealth">
                    <div><strong>‚ù§Ô∏è Health (+1 HP)</strong></div>
                    <div id="healthPrice">Price: $100</div>
                </div>
            </div>

            <button id="closeShop">Continue (next level)</button>
        </div>

        <!-- SuperUSD Investment Modal -->
        <div id="superUsdModal" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000000; padding: 40px; border: 5px solid #9CE500; z-index: 400; box-shadow: 0 0 40px rgba(156, 229, 0, 0.6), inset 0 0 30px rgba(156, 229, 0, 0.2); min-width: 400px;">
            <h2 style="text-align: center; color: #9CE500; text-shadow: 3px 3px 0px #000000, 0 0 20px #9CE500; margin-bottom: 20px;">üí∞ SuperUSD Investment üí∞</h2>
            <p style="color: #FFB6C1; text-align: center; margin-bottom: 20px; font-size: 18px;">Invest your money and get <strong style="color: #9CE500;">1.5x returns</strong> in the next shop!</p>

            <div style="text-align: center; margin-bottom: 20px;">
                <div style="color: #FF1493; font-size: 20px; margin-bottom: 10px;">Available: $<span id="investAvailable">0</span></div>
            </div>

            <!-- Collect Profit Button -->
            <button id="collectPayout" style="padding: 15px; margin-bottom: 20px; font-size: 18px; background: linear-gradient(135deg, #9CE500 0%, #7BC400 100%); border: 3px solid #9CE500; color: #000; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">üí∞ Collect Profit üí∞</button>


            <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px;">
                <button class="invest-btn" data-amount="10" style="padding: 15px; font-size: 18px; background: linear-gradient(135deg, #9CE500 0%, #7BC400 100%); border: 3px solid #9CE500; color: #000; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">Invest $10</button>
                <button class="invest-btn" data-amount="50" style="padding: 15px; font-size: 18px; background: linear-gradient(135deg, #9CE500 0%, #7BC400 100%); border: 3px solid #9CE500; color: #000; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">Invest $50</button>
                <button class="invest-btn" data-amount="100" style="padding: 15px; font-size: 18px; background: linear-gradient(135deg, #9CE500 0%, #7BC400 100%); border: 3px solid #9CE500; color: #000; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">Invest $100</button>
                <button class="invest-btn" data-amount="all" style="padding: 15px; font-size: 18px; background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); border: 3px solid #FFD700; color: #000; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">Invest ALL</button>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="withdrawInvestment" style="flex: 1; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%); border: 3px solid #FF1493; color: #000; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">Withdraw</button>
                <button id="closeSuperUsd" style="flex: 1; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #666 0%, #888 100%); border: 3px solid #666; color: #FFF; font-weight: bold; cursor: pointer; font-family: 'Courier New', monospace;">Close</button>
            </div>
        </div>

        <div id="gameOver">
            <h1 style="color: #ff4444; margin-bottom: 20px;">GAME OVER</h1>
            <h2>Final Score: <span id="finalScore">0</span></h2>
            <h3>Money: $<span id="finalMoney">0</span></h3>
            <button id="restart">Play Again</button>
            <button id="mainMenuButton">Main Menu</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', {
            alpha: false, // Disable transparency for better performance
            desynchronized: true // Allow low-latency rendering
        });

        // Load merchant head image
        const merchantHeadImg = new Image();
        merchantHeadImg.src = 'crouton.png?v=' + Date.now(); // Add cache buster to force reload

        // Load SuperUSD logo
        const superUsdLogo = new Image();
        superUsdLogo.src = 'Social_Logo_Round.svg?v=' + Date.now(); // Add cache buster

        // Game state
        const game = {
            running: false,
            score: 0,
            money: 0,
            health: 5,
            speed: 3,
            frameCount: 0,
            shopAvailable: false,
            weapon: 'colt',
            currentAmmo: 7,
            isReloading: false,
            reloadProgress: 0,
            isPumping: false,
            pumpProgress: 0,
            level: 0,
            nextShopScore: 500,
            shopMilestones: [500, 1500, 3000, 5000, 8000, 12000],
            ownedWeapons: ['colt'],
            lastShot: false,
            countdown: 0,
            muzzleFlashSize: 0,
            isNight: false,
            armor: 0,
            maxHealth: 5,
            nextPiggyBank: 50 + Math.random() * 400, // Random spawn point in first cycle (50-450)
            piggyBankSpawned: false,
            lastPiggyBankCycle: 0, // Track which 500-point cycle we're in
            volume: 0.1, // Sound effects volume level (0.0 to 1.0)
            musicVolume: 0.1, // Music volume level (0.0 to 1.0) - 10%
            musicEnabled: true, // Music on/off toggle
            kills: 0, // Track enemy kills
            helicopterActive: false, // Track if helicopter is alive
            nextHelicopterScore: 500, // Next score milestone for helicopter spawn (100% chance)
            nextRedHelicopterScore: 2000, // Next red helicopter spawn (starts at 2000)
            nextStreetLampScore: 100, // Next score milestone for street lamp spawn
            cutsceneActive: false, // Track if cutscene is playing
            cutscenePhase: 0, // Current phase of cutscene (0: entering, 1: dialog, 2: exiting)
            cutsceneTimer: 0, // Timer for cutscene phases
            pigX: 100, // Pig position during cutscene
            merchantDialogShown: false, // Track if dialog was shown
            inShop: false, // Track if player is browsing shop
            hoveredItem: null, // Currently hovered shop item
            mouseX: 0, // Mouse position in shop
            investment: 0, // Current investment amount
            pendingPayout: 0, // Pending payout from previous investment
            mouseY: 0,
            autoRunning: false, // Track if pig is auto-running to basement
            basementSpawned: false, // Track if basement was spawned for current milestone
            hasAskedRestock: false // Track if player already asked about restock
        };

        // Game Statistics System
        const GameStats = {
            storageKey: 'gangsterPigStats',

            // Load all game attempts from localStorage
            loadStats() {
                const stored = localStorage.getItem(this.storageKey);
                if (stored) {
                    try {
                        return JSON.parse(stored);
                    } catch (e) {
                        return [];
                    }
                }
                return [];
            },

            // Save a new game attempt
            saveAttempt(score, money, level, weapon, kills) {
                const stats = this.loadStats();
                const attempt = {
                    id: Date.now(),
                    date: new Date().toLocaleString('ru-RU'),
                    score: score,
                    money: money,
                    level: level,
                    weapon: weapon,
                    kills: kills || 0,
                    timestamp: Date.now()
                };

                stats.push(attempt);

                // Keep only last 50 attempts to avoid storage limits
                if (stats.length > 50) {
                    stats.shift();
                }

                localStorage.setItem(this.storageKey, JSON.stringify(stats));
                return attempt;
            },

            // Get best score
            getBestScore() {
                const stats = this.loadStats();
                if (stats.length === 0) return 0;
                return Math.max(...stats.map(s => s.score));
            },

            // Get total games played
            getTotalGames() {
                return this.loadStats().length;
            },

            // Get total money earned
            getTotalMoney() {
                const stats = this.loadStats();
                return stats.reduce((sum, s) => sum + s.money, 0);
            },

            // Get stats sorted by score (descending)
            getTopScores(limit = 10) {
                const stats = this.loadStats();
                return stats.sort((a, b) => b.score - a.score).slice(0, limit);
            },

            // Clear all stats
            clearStats() {
                localStorage.removeItem(this.storageKey);
            }
        };

        // 8-bit weapon sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Background music - optimized for performance
        const backgroundMusic = new Audio('NewWaweHookers.ogg');
        backgroundMusic.loop = true;
        backgroundMusic.volume = game.musicVolume;
        backgroundMusic.preload = 'auto'; // Preload the audio
        backgroundMusic.preservesPitch = false; // Better performance

        // Load audio asynchronously to prevent blocking
        backgroundMusic.load();

        // Function to create 8-bit weapon sounds
        function create8BitSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Different sound characteristics for each weapon
            switch(type) {
                case 'colt': // Pistol - short, sharp sound
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(game.volume * 0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;

                case 'shotgun': // Shotgun - deep, booming sound
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(game.volume * 0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;

                case 'tommy': // Tommy gun - rapid, staccato sound
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.05);
                    gainNode.gain.setValueAtTime(game.volume * 0.25, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;

                case 'sniper': // Sniper - powerful, echoing sound
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(180, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(game.volume * 0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
            }
        }

        // Play weapon sound
        function playShootSound(weaponType) {
            if (game.volume === 0) return; // Don't play if muted

            try {
                create8BitSound(weaponType);
            } catch (e) {
                console.log('Audio play failed:', e);
            }
        }

        // Play button click sound
        function playButtonSound(type = 'click') {
            if (game.volume === 0) return; // Don't play if muted

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                if (type === 'click') {
                    // Short, pleasant click sound
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.05);
                    gainNode.gain.setValueAtTime(game.volume * 0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                } else if (type === 'hover') {
                    // Subtle hover sound
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(game.volume * 0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.03);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.03);
                } else if (type === 'purchase') {
                    // Success/purchase sound
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(game.volume * 0.25, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'error') {
                    // Error/cannot afford sound
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(game.volume * 0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                }
            } catch (e) {
                console.log('Button sound play failed:', e);
            }
        }

        // Play explosion sound for barrel
        function playExplosionSound() {
            if (game.volume === 0) return; // Don't play if muted

            try {
                // Main explosion rumble (low frequency)
                const oscillator1 = audioContext.createOscillator();
                const gainNode1 = audioContext.createGain();

                oscillator1.connect(gainNode1);
                gainNode1.connect(audioContext.destination);

                oscillator1.type = 'sawtooth';
                oscillator1.frequency.setValueAtTime(120, audioContext.currentTime);
                oscillator1.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.3);

                gainNode1.gain.setValueAtTime(game.volume * 0.4, audioContext.currentTime);
                gainNode1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator1.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.3);

                // Secondary explosion crack (high frequency)
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();

                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);

                oscillator2.type = 'square';
                oscillator2.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator2.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.15);

                gainNode2.gain.setValueAtTime(game.volume * 0.3, audioContext.currentTime);
                gainNode2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                oscillator2.start(audioContext.currentTime);
                oscillator2.stop(audioContext.currentTime + 0.15);

                // Delayed rumble (bass aftershock)
                const oscillator3 = audioContext.createOscillator();
                const gainNode3 = audioContext.createGain();

                oscillator3.connect(gainNode3);
                gainNode3.connect(audioContext.destination);

                oscillator3.type = 'triangle';
                oscillator3.frequency.setValueAtTime(80, audioContext.currentTime + 0.1);
                oscillator3.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.4);

                gainNode3.gain.setValueAtTime(game.volume * 0.35, audioContext.currentTime + 0.1);
                gainNode3.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator3.start(audioContext.currentTime + 0.1);
                oscillator3.stop(audioContext.currentTime + 0.4);
            } catch (e) {
                console.log('Explosion sound play failed:', e);
            }
        }

        // Background music system removed for optimization

        // Player (Pig)
        const player = {
            x: 100,
            y: 450,
            width: 60,
            height: 60,
            velocityY: 0,
            gravity: 0.8,
            jumpPower: -18,
            isJumping: false,
            isCrouching: false,
            animFrame: 0,
            color: '#FF69B4'
        };

        // Weapons
        const weapons = {
            colt: {
                fireRate: 20,
                damage: 2,
                bulletSpeed: 18,
                spread: 1.68, // Reduced by 20% from 2.1 (originally 3, now reduced by 44% total)
                name: 'Colt M1911',
                magSize: 7,
                reloadTime: 60,
                auto: false,
                price: 0,
                bulletCount: 1
            },
            shotgun: {
                fireRate: 60, // Increased from 45 (slower fire rate)
                damage: 3,
                bulletSpeed: 12,
                spread: 9.072, // Reduced by 10% from 10.08 (originally 14.4, now reduced by 37% total)
                name: 'Pump Shotgun',
                magSize: 6, // Reduced from 8 to 6
                reloadTime: 90,
                auto: false,
                price: 600,
                bulletCount: 5,
                pumpTime: 50 // Increased from 30 (longer pump animation)
            },
            tommy: {
                fireRate: 8, // Reduced fire rate by 20% (was 7, now 8 - slower)
                damage: 1,
                bulletSpeed: 15,
                spread: 5.44, // Reduced spread by 20% (was 6.8, now 5.44 - more accurate)
                name: 'Tommy Gun',
                magSize: 50,
                reloadTime: 108, // Faster reload by 10% (was 120, now 108)
                auto: true,
                price: 500,
                bulletCount: 1
            },
            sniper: {
                fireRate: 80,
                damage: 5,
                bulletSpeed: 30,
                spread: 0,
                name: 'Sniper Rifle',
                magSize: 5,
                reloadTime: 120,
                auto: false,
                price: 300,
                bulletCount: 1
            },
            ak47: {
                fireRate: 14, // Reduced fire rate by 30% (was 11, now 14 - slower)
                damage: 3,
                bulletSpeed: 19,
                spread: 2,
                name: 'AK-47',
                magSize: 30,
                reloadTime: 137, // Increased reload time by 30% (was 105, now 137)
                auto: true,
                price: 400,
                bulletCount: 1
            }
        };

        // Shop counters layout
        const shopCounters = {
            weapons: {
                x: 100,
                y: 150,
                width: 350,
                height: 180,
                label: 'üî´ WEAPONS',
                items: [
                    { id: 'sniper', x: 100, y: 225, width: 70, height: 35 },   // $300 - leftmost
                    { id: 'ak47', x: 180, y: 225, width: 70, height: 35 },     // $400 - second
                    { id: 'tommy', x: 260, y: 225, width: 70, height: 35 },    // $500 - third
                    { id: 'shotgun', x: 340, y: 225, width: 70, height: 35 }   // $600 - rightmost
                ]
            },
            equipment: {
                x: 500,
                y: 150,
                width: 250,
                height: 180,
                label: 'üõ°Ô∏è EQUIPMENT',
                items: [
                    { id: 'armor', x: 530, y: 200, width: 90, height: 60 },
                    { id: 'health', x: 640, y: 200, width: 90, height: 60 }
                ]
            },
            superusd: {
                safeX: 850,  // Position on floor (right side)
                safeY: 350,  // On the floor
                safeWidth: 100,
                safeHeight: 120,
                labelY: 330  // Label above safe
            }
        };

        // Arrays
        const bullets = [];
        const enemies = [];
        const obstacles = [];
        const buildings = [];
        const distantBuildings = []; // Far background layer
        const foregroundBuildings = []; // Close foreground layer
        const piggyBanks = [];
        const droppedBarrels = []; // Explosive barrels dropped by helicopter
        const streetLamps = []; // Street lamps that appear every 150 points
        const basementEntrances = []; // Basement shop entrances

        // Object pooling system for better performance (reduces GC pressure)
        const objectPools = {
            bullets: [],
            enemies: [],
            obstacles: []
        };

        // Get object from pool or create new one
        function getFromPool(type) {
            const pool = objectPools[type];
            if (pool.length > 0) {
                return pool.pop();
            }
            return {}; // Return empty object to be filled
        }

        // Return object to pool instead of deleting
        function returnToPool(type, obj) {
            const pool = objectPools[type];
            if (pool.length < 50) { // Limit pool size to prevent memory bloat
                // Clear object properties
                for (let key in obj) {
                    delete obj[key];
                }
                pool.push(obj);
            }
        }

        // Building cache system for performance optimization
        const buildingCache = {
            distant: new Map(),
            middle: new Map(),
            foreground: new Map()
        };

        // Create cached building image
        function getCachedBuilding(type, building, index) {
            const cache = buildingCache[type];

            if (cache.has(index)) {
                return cache.get(index);
            }

            // Create offscreen canvas for this building
            let canvas, width, height;

            if (type === 'distant') {
                width = building.width;
                height = Math.ceil(building.height * 0.6) + 50; // Extra space for antenna
                canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Building body
                ctx.fillStyle = building.color;
                ctx.fillRect(0, height - building.height * 0.6, width, building.height * 0.6);

                // Simple windows
                ctx.fillStyle = 'rgba(255, 255, 200, 0.4)';
                for (let j = 0; j < 4; j++) {
                    for (let i = 0; i < 3; i++) {
                        if (Math.random() > 0.5) {
                            ctx.fillRect(30 + i * 40, height - building.height * 0.6 + 5 + j * 25, 15, 15);
                        }
                    }
                }

                // Antenna
                if (building.hasAntenna) {
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                    ctx.fillRect(width / 2 - 2, 0, 4, 30);
                    ctx.fillRect(width / 2 - 6, 0, 12, 6);
                }
            } else if (type === 'middle') {
                width = building.width + 10;
                height = building.height + 60;
                canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                const buildingY = height - building.height - 8;

                // Building body
                ctx.fillStyle = building.color;
                ctx.fillRect(5, buildingY, building.width, building.height);

                // Building edge highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fillRect(5, buildingY, 8, building.height);

                // Windows
                ctx.fillStyle = 'rgba(255, 255, 150, 0.7)';
                let windowIndex = 0;
                for (let j = 0; j < Math.floor(building.height / 30); j++) {
                    for (let i = 0; i < 6; i++) {
                        if (building.windows[windowIndex]) {
                            ctx.fillRect(25 + i * 50, buildingY + 10 + j * 30, 25, 25);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.fillRect(25 + i * 50, buildingY + 10 + j * 30 + 25, 25, 2);
                            ctx.fillStyle = 'rgba(255, 255, 150, 0.7)';
                        }
                        windowIndex++;
                    }
                }

                // Roof ledge
                ctx.fillStyle = 'rgba(80, 80, 80, 0.8)';
                ctx.fillRect(0, buildingY - 8, building.width + 10, 8);

                // Roof decorations
                if (building.roofType === 1) {
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(building.width / 2 + 5 - 3, buildingY - 50, 6, 50);
                    ctx.fillRect(building.width / 2 + 5 - 10, buildingY - 45, 20, 4);
                    ctx.fillRect(building.width / 2 + 5 - 8, buildingY - 35, 16, 3);
                }

                // Air vents
                if (building.hasVents) {
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(55, buildingY - 15, 20, 10);
                    ctx.fillRect(95, buildingY - 15, 20, 10);
                }
            } else { // foreground
                width = building.width;
                height = building.height;
                canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Building body
                ctx.fillStyle = building.color;
                ctx.fillRect(0, 0, width, height);

                // Windows
                ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
                let windowIndex = 0;
                for (let j = 0; j < Math.floor(height / 35); j++) {
                    for (let i = 0; i < 4; i++) {
                        if (building.windows[windowIndex]) {
                            ctx.fillRect(30 + i * 55, 15 + j * 35, 30, 30);
                        }
                        windowIndex++;
                    }
                }

                // Dark edge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(width - 10, 0, 10, height);
            }

            cache.set(index, canvas);
            return canvas;
        }

        // Input
        const keys = {};
        let mouseDown = false;
        let shootCooldown = 0;

        // Initialize buildings for background with multiple layers
        function initBuildings() {
            // Distant buildings (far back, smaller, lighter)
            for (let i = 0; i < 6; i++) {
                const buildingHeight = 120 + Math.random() * 80;
                distantBuildings.push({
                    x: i * 250,
                    height: buildingHeight,
                    width: 180,
                    color: `hsl(${200 + Math.random() * 40}, 20%, ${45 + Math.random() * 15}%)`,
                    hasAntenna: Math.random() > 0.6
                });
            }

            // Middle buildings (main layer)
            for (let i = 0; i < 4; i++) {
                const buildingHeight = 350 + Math.random() * 130;
                const windows = [];

                // Generate random static windows
                for (let row = 0; row < Math.floor(buildingHeight / 30); row++) {
                    for (let col = 0; col < 6; col++) {
                        windows.push(Math.random() > 0.7);
                    }
                }

                buildings.push({
                    x: i * 400,
                    height: buildingHeight,
                    width: 360,
                    color: `hsl(${200 + Math.random() * 40}, 30%, ${20 + Math.random() * 20}%)`,
                    windows: windows,
                    roofType: Math.floor(Math.random() * 3), // 0=flat, 1=antenna, 2=sign
                    hasVents: Math.random() > 0.5
                });
            }

            // Foreground buildings (close, taller, darker - partial view)
            for (let i = 0; i < 3; i++) {
                const buildingHeight = 420 + Math.random() * 100;
                const windows = [];

                for (let row = 0; row < Math.floor(buildingHeight / 35); row++) {
                    for (let col = 0; col < 4; col++) {
                        windows.push(Math.random() > 0.6);
                    }
                }

                foregroundBuildings.push({
                    x: i * 500 - 100,
                    height: buildingHeight,
                    width: 280,
                    color: `hsl(${200 + Math.random() * 40}, 35%, ${12 + Math.random() * 15}%)`,
                    windows: windows
                });
            }
        }

        // Draw pixel-style pig
        function drawPig() {
            const px = player.x;
            const py = player.isCrouching ? player.y + 15 : player.y;
            const scale = player.isCrouching ? 0.8 : 1;

            // Animation frame for running
            const legOffset = !player.isJumping ? Math.sin(game.frameCount * 0.3) * 3 : 0;

            ctx.save();
            ctx.translate(px, py);
            ctx.scale(scale, scale);

            // Back leg (black pants on leg)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(15, 45 + legOffset, 8, 18);

            // Pig body (pink torso)
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(10, 25, 35, 25);

            // Black pants (lower body)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(10, 40, 35, 20); // Main pants body

            // Pants details (seams)
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(27, 40, 1, 20); // Center seam

            // Belt
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(10, 39, 35, 3); // Belt
            ctx.fillStyle = '#C0C0C0'; // Silver buckle
            ctx.fillRect(24, 39, 5, 3);

            // White shirt (gangster suit - now shows above pants)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(12, 27, 31, 13);

            // Black suit jacket
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(8, 27, 8, 20); // Left lapel
            ctx.fillRect(37, 27, 8, 20); // Right lapel

            // Red tie
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(24, 30, 5, 12);
            ctx.fillRect(22, 30, 9, 3);

            // Pig head
            ctx.fillStyle = '#FFC0CB';
            ctx.fillRect(15, 10, 25, 20);

            // Snout
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(35, 17, 10, 10);

            // Nostrils
            ctx.fillStyle = '#FF69B4';
            ctx.fillRect(37, 21, 2, 3);
            ctx.fillRect(41, 21, 2, 3);

            // Eye
            ctx.fillStyle = '#000000';
            ctx.fillRect(28, 15, 4, 4);

            // Eyebrow (angry gangster look)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(26, 13, 7, 2);

            // Ear
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(12, 15, 5, 6);

            // Front leg (animation with black pants)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(30, 45 - legOffset, 8, 18);

            // Shoes (black)
            ctx.fillStyle = '#000000';
            ctx.fillRect(13, 58 + legOffset, 10, 4);
            ctx.fillRect(28, 58 - legOffset, 10, 4);

            // Draw weapon based on current weapon
            if (game.weapon === 'colt') {
                // Colt M1911 - compact pistol
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 32, 18, 6); // Barrel
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(48, 34, 3, 8); // Magazine
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(50, 35, 6, 6); // Grip
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(61, 31, 2, 8); // Front sight

                // Muzzle flash (enhanced)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(63, 30 - flashSize/2, flashSize, 10 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(66, 32 - flashSize/4, flashSize/2, 6 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(68, 34, flashSize/4, 2);
                }
            } else if (game.weapon === 'shotgun') {
                // Pump Shotgun - longer, thicker
                ctx.fillStyle = '#654321';
                ctx.fillRect(45, 30, 28, 8); // Main body (wood)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 32, 28, 4); // Barrel (metal)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(50, 35, 8, 6); // Pump handle
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(58, 34, 4, 6); // Trigger area
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(71, 31, 2, 6); // Front sight

                // Muzzle flash (bigger for shotgun)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize * 1.5;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(73, 28 - flashSize/2, flashSize + 4, 12 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(77, 30 - flashSize/4, flashSize, 8 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(79, 32, flashSize/2, 4);
                }
            } else if (game.weapon === 'tommy') {
                // Tommy Gun - iconic with drum mag
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 30, 25, 6); // Main barrel

                // Round drum magazine (iconic)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(50, 32, 12, 12); // Drum
                ctx.fillRect(52, 30, 8, 16); // Extended drum

                // Front sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(68, 28, 3, 10);

                // Wooden grip
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(48, 36, 6, 8);

                // Foregrip
                ctx.fillStyle = '#654321';
                ctx.fillRect(58, 36, 4, 6);

                // Muzzle flash
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(70, 28 - flashSize/2, flashSize + 2, 10 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(74, 30 - flashSize/4, flashSize, 6 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(76, 32, flashSize/3, 2);
                }
            } else if (game.weapon === 'sniper') {
                // Sniper Rifle - long, precise, with scope
                // Main barrel (very long)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(45, 32, 40, 4); // Long thin barrel

                // Receiver (body)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(48, 30, 15, 8);

                // Scope (mounted on top)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(52, 25, 12, 4); // Scope tube
                ctx.fillStyle = '#87CEEB'; // Blue tint for lens
                ctx.fillRect(53, 26, 2, 2); // Front lens
                ctx.fillRect(61, 26, 2, 2); // Rear lens

                // Stock (wooden)
                ctx.fillStyle = '#654321';
                ctx.fillRect(43, 32, 8, 6);
                ctx.fillRect(40, 33, 5, 4); // Extended stock

                // Bipod (folded)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(70, 36, 2, 4);
                ctx.fillRect(75, 36, 2, 4);

                // Magazine
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(56, 36, 8, 4);

                // Front sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(83, 30, 2, 6);

                // Muzzle flash (intense and focused)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize * 1.2;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(85, 30 - flashSize/2, flashSize + 3, 8 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(89, 31 - flashSize/4, flashSize + 2, 6 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(92, 33, flashSize, 2);
                    // Laser beam effect
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(85, 33, 100, 1);
                }
            } else if (game.weapon === 'ak47') {
                // AK-47 - realistic iconic design
                // Wooden stock (distinctive AK feature)
                ctx.fillStyle = '#654321';
                ctx.fillRect(38, 33, 10, 5); // Stock base

                // Main receiver/body (black metal)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(45, 30, 24, 8); // Main receiver body

                // Dust cover (top of receiver)
                ctx.fillStyle = '#2C2C2C';
                ctx.fillRect(47, 29, 20, 2); // Dust cover on top

                // Rear sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(55, 27, 3, 3); // Rear sight block

                // Barrel (extending forward)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(67, 32, 16, 4); // Barrel

                // Gas tube (above barrel - iconic AK)
                ctx.fillStyle = '#3A3A3A';
                ctx.fillRect(67, 30, 14, 2); // Gas tube

                // Wooden handguard (under gas tube)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(67, 36, 10, 2); // Lower handguard

                // Front sight block
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(79, 30, 2, 6); // Front sight block
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(79, 30, 2, 2); // Sight post

                // Slant muzzle brake (iconic AK feature)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(81, 31, 2, 5); // Muzzle brake
                ctx.fillRect(82, 32, 2, 3); // Brake cut

                // Curved magazine (most iconic AK feature)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(54, 38, 7, 3); // Top of mag
                ctx.fillRect(55, 41, 6, 8); // Curved body
                ctx.fillRect(56, 49, 4, 2); // Bottom curve

                // Magazine lips (brass visible)
                ctx.fillStyle = '#B8860B';
                ctx.fillRect(55, 38, 5, 1); // Brass showing

                // Pistol grip (distinctive angle)
                ctx.fillStyle = '#654321';
                ctx.fillRect(48, 38, 4, 6); // Grip
                ctx.fillRect(47, 44, 5, 3); // Grip bottom

                // Trigger guard
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(52, 37, 4, 1); // Guard top
                ctx.fillRect(52, 41, 4, 1); // Guard bottom

                // Selector switch
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(46, 34, 2, 3); // Selector lever

                // Muzzle flash (when firing)
                if (game.muzzleFlashSize > 0) {
                    const flashSize = game.muzzleFlashSize * 1.3;
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(83, 30 - flashSize/2, flashSize + 4, 8 + flashSize);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(86, 32 - flashSize/4, flashSize + 2, 4 + flashSize/2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(88, 33, flashSize, 2);
                }
            }

            // Fedora hat (gangster style)
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(13, 5, 24, 6); // Hat brim
            ctx.fillRect(16, 0, 18, 6); // Hat top

            // Hat band
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(16, 4, 18, 2);

            ctx.restore();
        }

        // Draw city background
        function drawBackground() {
            // Day/Night cycle every 1500 points
            // Score 0-700: Day with sun at fixed position
            // Score 700-750: Sun descends and disappears behind horizon
            // Score 750: Sun fully hidden, moon starts rising from same position
            // Score 750-800: Moon rises to sun's original position
            // Score 800-1450: Night with moon at fixed position
            // Score 1450-1500: Moon descends, sun rises (cycle repeats)

            const cycleLength = 1500;
            const scoreInCycle = game.score % cycleLength;

            // Phase boundaries
            const sunsetStart = 700;      // Sun starts descending
            const sunsetEnd = 750;        // Sun fully hidden, moon starts rising
            const moonRiseEnd = 800;      // Moon fully risen
            const sunriseStart = 1450;    // Moon starts descending, sun rises

            // Determine if night
            game.isNight = scoreInCycle >= sunsetEnd && scoreInCycle < sunriseStart;

            // Calculate sky transition (0 = day, 1 = night)
            let skyTransition = 0;
            if (scoreInCycle >= sunsetStart && scoreInCycle < sunsetEnd) {
                // Transitioning to night (700-750)
                skyTransition = (scoreInCycle - sunsetStart) / (sunsetEnd - sunsetStart);
            } else if (scoreInCycle >= sunsetEnd && scoreInCycle < sunriseStart) {
                // Full night (750-1450)
                skyTransition = 1;
            } else if (scoreInCycle >= sunriseStart) {
                // Transitioning to day (1450-1500)
                skyTransition = 1 - (scoreInCycle - sunriseStart) / (cycleLength - sunriseStart);
            }

            // Sky gradient with smooth transition
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

            // Interpolate between day and night colors
            const dayColor1 = { r: 135, g: 206, b: 235 }; // #87CEEB
            const dayColor2 = { r: 224, g: 246, b: 255 }; // #E0F6FF
            const nightColor1 = { r: 10, g: 10, b: 46 };   // #0A0A2E
            const nightColor2 = { r: 26, g: 26, b: 78 };   // #1A1A4E

            const color1 = {
                r: Math.floor(dayColor1.r + (nightColor1.r - dayColor1.r) * skyTransition),
                g: Math.floor(dayColor1.g + (nightColor1.g - dayColor1.g) * skyTransition),
                b: Math.floor(dayColor1.b + (nightColor1.b - dayColor1.b) * skyTransition)
            };
            const color2 = {
                r: Math.floor(dayColor2.r + (nightColor2.r - dayColor2.r) * skyTransition),
                g: Math.floor(dayColor2.g + (nightColor2.g - dayColor2.g) * skyTransition),
                b: Math.floor(dayColor2.b + (nightColor2.b - dayColor2.b) * skyTransition)
            };

            gradient.addColorStop(0, `rgb(${color1.r}, ${color1.g}, ${color1.b})`);
            gradient.addColorStop(1, `rgb(${color2.r}, ${color2.g}, ${color2.b})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Celestial bodies
            const celestialX = canvas.width - 150;
            const skyPosition = 100;           // Normal position in sky
            const groundHorizon = canvas.height; // Horizon level

            // SUN
            if (scoreInCycle < sunsetEnd || scoreInCycle >= sunriseStart) {
                let sunY = skyPosition;
                let sunOpacity = 1;

                if (scoreInCycle >= sunsetStart && scoreInCycle < sunsetEnd) {
                    // Sun descending (700-750)
                    const sunsetProgress = (scoreInCycle - sunsetStart) / (sunsetEnd - sunsetStart);
                    sunY = skyPosition + (groundHorizon - skyPosition) * sunsetProgress;
                    sunOpacity = Math.max(0, 1 - sunsetProgress);
                } else if (scoreInCycle >= sunriseStart) {
                    // Sun rising (1450-1500)
                    const sunriseProgress = (scoreInCycle - sunriseStart) / (cycleLength - sunriseStart);
                    sunY = groundHorizon - (groundHorizon - skyPosition) * sunriseProgress;
                    sunOpacity = sunriseProgress;
                }

                if (sunOpacity > 0 && sunY < groundHorizon) {
                    // Sun
                    ctx.fillStyle = `rgba(255, 223, 0, ${sunOpacity})`;
                    ctx.fillRect(celestialX - 30, sunY - 30, 60, 60);
                    // Sun glow
                    ctx.fillStyle = `rgba(255, 200, 50, ${sunOpacity * 0.5})`;
                    ctx.fillRect(celestialX - 35, sunY - 35, 70, 70);
                    // Sun rays
                    ctx.fillStyle = `rgba(255, 223, 0, ${sunOpacity * 0.7})`;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const rx = Math.cos(angle) * 45;
                        const ry = Math.sin(angle) * 45;
                        ctx.fillRect(celestialX + rx - 2, sunY + ry - 2, 15, 4);
                    }
                }
            }

            // MOON
            if (scoreInCycle >= sunsetEnd && scoreInCycle < sunriseStart) {
                let moonY = skyPosition;
                let moonOpacity = 1;

                if (scoreInCycle < moonRiseEnd) {
                    // Moon rising (750-800)
                    const moonRiseProgress = (scoreInCycle - sunsetEnd) / (moonRiseEnd - sunsetEnd);
                    moonY = groundHorizon - (groundHorizon - skyPosition) * moonRiseProgress;
                    moonOpacity = 0.3 + 0.7 * moonRiseProgress;
                }

                if (moonY < groundHorizon) {
                    // Moon
                    ctx.fillStyle = `rgba(240, 240, 255, ${moonOpacity})`;
                    ctx.fillRect(celestialX - 25, moonY - 25, 50, 50);
                    // Moon craters
                    ctx.fillStyle = `rgba(200, 200, 220, ${moonOpacity})`;
                    ctx.fillRect(celestialX - 10, moonY - 10, 15, 15);
                    ctx.fillRect(celestialX + 5, moonY + 5, 10, 10);
                    ctx.fillRect(celestialX - 15, moonY + 8, 8, 8);
                    // Moon glow
                    ctx.fillStyle = `rgba(200, 200, 255, ${moonOpacity * 0.3})`;
                    ctx.fillRect(celestialX - 30, moonY - 30, 60, 60);
                }
            }

            // Stars at night (fade in/out with sky transition)
            if (skyTransition > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${skyTransition})`;
                for (let i = 0; i < 50; i++) {
                    const starX = (i * 123 + game.frameCount * 0.1) % canvas.width;
                    const starY = (i * 456) % 400;
                    ctx.fillRect(starX, starY, 2, 2);
                }
            }

            // LAYER 1: Distant buildings (slowest parallax) - OPTIMIZED WITH CACHING
            distantBuildings.forEach((building, index) => {
                building.x -= game.speed * 0.15;

                if (building.x + building.width < 0) {
                    building.x = canvas.width;
                    building.height = 120 + Math.random() * 80;
                    building.color = `hsl(${200 + Math.random() * 40}, 20%, ${45 + Math.random() * 15}%)`;
                    building.hasAntenna = Math.random() > 0.6;
                    // Clear cache when building regenerates
                    buildingCache.distant.delete(index);
                }

                // Use cached building image
                const cachedImage = getCachedBuilding('distant', building, index);
                const drawY = canvas.height - 100 - building.height * 0.6 - (building.hasAntenna ? 30 : 0);
                ctx.drawImage(cachedImage, building.x, drawY);
            });

            // LAYER 2: Middle buildings (medium parallax) - OPTIMIZED WITH CACHING
            buildings.forEach((building, index) => {
                building.x -= game.speed * 0.3;

                if (building.x + building.width < 0) {
                    building.x = canvas.width;
                    building.height = 350 + Math.random() * 130;
                    building.width = 360;
                    building.color = `hsl(${200 + Math.random() * 40}, 30%, ${20 + Math.random() * 20}%)`;
                    building.roofType = Math.floor(Math.random() * 3);
                    building.hasVents = Math.random() > 0.5;

                    // Regenerate windows
                    building.windows = [];
                    for (let row = 0; row < Math.floor(building.height / 30); row++) {
                        for (let col = 0; col < 6; col++) {
                            building.windows.push(Math.random() > 0.7);
                        }
                    }

                    // Clear cache when building regenerates
                    buildingCache.middle.delete(index);
                }

                // Use cached building image
                const cachedImage = getCachedBuilding('middle', building, index);
                const drawY = canvas.height - 100 - building.height - 8;
                ctx.drawImage(cachedImage, building.x - 5, drawY);
            });

            // LAYER 3: Foreground buildings (fastest parallax) - OPTIMIZED WITH CACHING
            foregroundBuildings.forEach((building, index) => {
                building.x -= game.speed * 0.5;

                if (building.x + building.width < 0) {
                    building.x = canvas.width + Math.random() * 200;
                    building.height = 420 + Math.random() * 100;
                    building.color = `hsl(${200 + Math.random() * 40}, 35%, ${12 + Math.random() * 15}%)`;

                    // Regenerate windows
                    building.windows = [];
                    for (let row = 0; row < Math.floor(building.height / 35); row++) {
                        for (let col = 0; col < 4; col++) {
                            building.windows.push(Math.random() > 0.6);
                        }
                    }

                    // Clear cache when building regenerates
                    buildingCache.foreground.delete(index);
                }

                // Use cached building image
                const cachedImage = getCachedBuilding('foreground', building, index);
                const drawY = canvas.height - 100 - building.height;
                ctx.drawImage(cachedImage, building.x, drawY);
            });

            // GROUND - Detailed street with sidewalks
            // Sidewalk
            ctx.fillStyle = '#707070';
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

            // Road surface
            ctx.fillStyle = '#404040';
            ctx.fillRect(0, canvas.height - 85, canvas.width, 70);

            // Sidewalk edge
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, canvas.height - 86, canvas.width, 3);

            // Street lane lines
            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < canvas.width; i += 60) {
                ctx.fillRect((i - (game.frameCount * game.speed) % 60), canvas.height - 52, 35, 4);
            }
        }

        // Spawn enemy
        function spawnEnemy() {
            // Don't spawn ground enemies if helicopter is active
            if (game.helicopterActive) {
                return;
            }

            const spawnX = canvas.width;

            // Check if basement entrance is near the spawn area (same safe zone as obstacles)
            for (let i = 0; i < basementEntrances.length; i++) {
                const entrance = basementEntrances[i];
                const bufferBefore = 2000; // Extra long safe zone before entrance
                const bufferAfter = 1500;  // Safe zone after entrance
                const entranceWidth = 200;

                if (spawnX >= entrance.x - bufferBefore && spawnX <= entrance.x + entranceWidth + bufferAfter) {
                    // Entrance is too close, don't spawn enemy
                    return;
                }
            }

            const types = ['alpha', 'warrior', 'beast'];
            const enemyType = types[Math.floor(Math.random() * types.length)];

            // Get enemy from pool - OPTIMIZED
            const enemy = getFromPool('enemies');
            enemy.x = canvas.width;
            enemy.y = 400;
            enemy.width = 60;
            enemy.height = 100;
            enemy.health = enemyType === 'beast' ? 4 : (enemyType === 'alpha' ? 3 : 2);
            enemy.type = enemyType;
            enemy.speed = 2 + Math.random() * 1.5;

            enemies.push(enemy);
        }

        // Spawn helicopter enemy
        function spawnHelicopter(isRed = false) {
            if (game.helicopterActive) {
                return; // Only one helicopter at a time
            }

            game.helicopterActive = true;

            enemies.push({
                x: canvas.width,
                y: 250, // Flying at jump height
                width: 210, // 3x bigger (70 * 3)
                height: 150, // 3x bigger (50 * 3)
                health: isRed ? 32 : 12, // Red helicopter has 32 HP, normal has 12 HP
                type: isRed ? 'red_helicopter' : 'helicopter',
                speed: 0, // Stationary - stays on right side
                dropTimer: 120, // Drop barrel every 2 seconds (120 frames at 60fps)
                dropCooldown: 120,
                targetX: canvas.width - 250 // Position on right side
            });
        }

        // Spawn obstacle
        function spawnObstacle() {
            const spawnX = canvas.width;

            // Check if piggy bank building is near the spawn area
            for (let i = 0; i < piggyBanks.length; i++) {
                const bank = piggyBanks[i];
                // Don't spawn obstacles if building is in or near spawn area
                // Bank extends from bank.x to bank.x + bank.width (520px wide)
                // Add very large buffer zone before and after building for clear area
                const bufferBefore = 1200; // Large safe zone before building
                const bufferAfter = 1200;  // Large safe zone after building

                if (spawnX >= bank.x - bufferBefore && spawnX <= bank.x + bank.width + bufferAfter) {
                    // Building is too close, don't spawn
                    return null;
                }
            }

            // Check if basement entrance is near the spawn area
            for (let i = 0; i < basementEntrances.length; i++) {
                const entrance = basementEntrances[i];
                // Basement entrance width is 200px
                // Add very large buffer zone before and after entrance for safe approach
                const bufferBefore = 2000; // Extra long safe zone before entrance (2000px)
                const bufferAfter = 1500;  // Safe zone after entrance
                const entranceWidth = 200;

                if (spawnX >= entrance.x - bufferBefore && spawnX <= entrance.x + entranceWidth + bufferAfter) {
                    // Entrance is too close, don't spawn
                    return null;
                }
            }

            const types = ['crate', 'barrel', 'tire', 'cone', 'trash', 'fence', 'hydrant', 'mailbox', 'dumpster', 'sign', 'car'];
            const type = types[Math.floor(Math.random() * types.length)];

            let width, height, y;
            if (type === 'tire') {
                width = 25;
                height = 25;
            } else if (type === 'cone') {
                width = 20;
                height = 30;
            } else if (type === 'trash') {
                width = 30;
                height = 35;
            } else if (type === 'fence') {
                width = 40;
                height = 45;
            } else if (type === 'hydrant') {
                width = 25;
                height = 35;
            } else if (type === 'mailbox') {
                width = 30;
                height = 40;
            } else if (type === 'dumpster') {
                width = 60;
                height = 55;
            } else if (type === 'sign') {
                width = 25;
                height = 50;
            } else if (type === 'car') {
                width = 200;  // 80 * 2.5
                height = 112; // 45 * 2.5
            } else {
                width = 20 + Math.random() * 15;
                height = 25 + Math.random() * 20;
            }

            // Position obstacles on ground
            y = 500 - height;

            const obstacle = {
                x: canvas.width,
                y: y,
                width: width,
                height: height,
                type: type,
                animFrame: 0 // For animated obstacles
            };

            obstacles.push(obstacle);
            return obstacle;
        }

        // Spawn car obstacle
        function spawnCarObstacle() {
            const spawnX = canvas.width;

            // Check if piggy bank building is near the spawn area
            for (let i = 0; i < piggyBanks.length; i++) {
                const bank = piggyBanks[i];
                const bufferBefore = 1200; // Large safe zone before building
                const bufferAfter = 1200;  // Large safe zone after building

                if (spawnX >= bank.x - bufferBefore && spawnX <= bank.x + bank.width + bufferAfter) {
                    return null;
                }
            }

            // Check if basement entrance is near the spawn area
            for (let i = 0; i < basementEntrances.length; i++) {
                const entrance = basementEntrances[i];
                const bufferBefore = 2000; // Extra long safe zone before entrance (2000px)
                const bufferAfter = 1500;  // Safe zone after entrance
                const entranceWidth = 200;

                if (spawnX >= entrance.x - bufferBefore && spawnX <= entrance.x + entranceWidth + bufferAfter) {
                    return null;
                }
            }

            const width = 200;  // 80 * 2.5
            const height = 112; // 45 * 2.5
            const y = 500 - height;

            const car = {
                x: canvas.width,
                y: y,
                width: width,
                height: height,
                type: 'car',
                animFrame: 0,
                colorVariant: Math.floor(Math.random() * 3) // 0, 1, or 2 for 3 color variants
            };

            obstacles.push(car);
            return car;
        }

        // Draw enemy (werewolf) - REALISTIC AND DETAILED
        function drawEnemy(enemy) {
            ctx.save();

            const legOffset = Math.sin(game.frameCount * 0.35 + enemy.x * 0.1) * 6;
            const ex = enemy.x;
            const ey = enemy.y;

            // Check if it's a helicopter enemy
            if (enemy.type === 'helicopter' || enemy.type === 'red_helicopter') {
                // Draw Apache-style attack helicopter (3x scale)
                const rotorOffset = Math.sin(game.frameCount * 0.5) * 4;
                const scale = 3;

                // Color scheme based on helicopter type
                const isRed = enemy.type === 'red_helicopter';
                const mainColor = isRed ? '#CC0000' : '#3A4A2A'; // Bright red or dark green
                const secondaryColor = isRed ? '#FF0000' : '#2A3A1A'; // Pure red or darker green
                const cockpitColor = isRed ? '#8B0000' : '#1A2A0A'; // Dark red or very dark green

                // Long tail boom (extending far back)
                ctx.fillStyle = mainColor;
                ctx.fillRect(ex - 30*scale, ey + 28*scale, 50*scale, 6*scale); // Long thin tail

                // Tail rotor mechanism
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(ex - 32*scale, ey + 25*scale, 6*scale, 12*scale); // Tail fin

                // Tail rotor (spinning vertically)
                const tailRotorRotation = (game.frameCount * 0.4) % 2;
                ctx.fillStyle = 'rgba(60, 60, 60, 0.7)';
                if (tailRotorRotation < 1) {
                    ctx.fillRect(ex - 35*scale, ey + 22*scale, 2*scale, 20*scale); // Vertical blade
                } else {
                    ctx.fillRect(ex - 36*scale, ey + 30*scale, 4*scale, 4*scale); // Horizontal blade
                }

                // Main body (sleek, angular Apache-style)
                ctx.fillStyle = mainColor;
                ctx.fillRect(ex + 10*scale, ey + 24*scale, 55*scale, 22*scale); // Main fuselage

                // Angular nose (aggressive front)
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(ex + 60*scale, ey + 26*scale, 12*scale, 18*scale); // Pointed nose
                ctx.fillRect(ex + 70*scale, ey + 28*scale, 5*scale, 14*scale); // Nose tip

                // Cockpit (tandem seating - Apache style)
                ctx.fillStyle = cockpitColor;
                ctx.fillRect(ex + 45*scale, ey + 18*scale, 20*scale, 18*scale); // Rear cockpit

                // Windshield (dark tinted)
                ctx.fillStyle = isRed ? '#4B0000' : '#0A1A0A';
                ctx.fillRect(ex + 47*scale, ey + 20*scale, 16*scale, 10*scale);
                ctx.fillRect(ex + 62*scale, ey + 20*scale, 10*scale, 10*scale); // Front cockpit glass

                // Wolf pilot visible (menacing)
                ctx.fillStyle = '#3A3A3A';
                ctx.fillRect(ex + 50*scale, ey + 22*scale, 6*scale, 6*scale);
                ctx.fillStyle = '#FF0000'; // Red glowing eyes
                ctx.fillRect(ex + 51*scale, ey + 24*scale, 2*scale, 2*scale);
                ctx.fillRect(ex + 54*scale, ey + 24*scale, 2*scale, 2*scale);

                // Engine exhaust ports
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(ex + 15*scale, ey + 45*scale, 8*scale, 4*scale);
                ctx.fillRect(ex + 35*scale, ey + 45*scale, 8*scale, 4*scale);

                // Stub wings with weapons
                ctx.fillStyle = '#2A3A1A';
                ctx.fillRect(ex + 20*scale, ey + 38*scale, 35*scale, 6*scale); // Wing mounts

                // Rocket pods (left side)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(ex + 18*scale, ey + 42*scale, 8*scale, 12*scale); // Left pod
                // Rockets visible
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(ex + 19*scale, ey + 44*scale, 2*scale, 8*scale);
                ctx.fillRect(ex + 22*scale, ey + 44*scale, 2*scale, 8*scale);

                // Rocket pods (right side)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(ex + 47*scale, ey + 42*scale, 8*scale, 12*scale); // Right pod
                // Rockets visible
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(ex + 48*scale, ey + 44*scale, 2*scale, 8*scale);
                ctx.fillRect(ex + 51*scale, ey + 44*scale, 2*scale, 8*scale);

                // Chain gun (nose mounted)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(ex + 72*scale, ey + 36*scale, 6*scale, 4*scale);

                // Landing gear
                ctx.fillStyle = '#2C2C2C';
                ctx.fillRect(ex + 25*scale, ey + 46*scale, 4*scale, 8*scale); // Left gear
                ctx.fillRect(ex + 45*scale, ey + 46*scale, 4*scale, 8*scale); // Right gear
                // Wheels
                ctx.fillStyle = '#1A1A1A';
                ctx.fillRect(ex + 23*scale, ey + 52*scale, 8*scale, 4*scale);
                ctx.fillRect(ex + 43*scale, ey + 52*scale, 8*scale, 4*scale);

                // Main rotor mast
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(ex + 35*scale, ey + 12*scale, 6*scale, 12*scale);

                // Main rotor hub
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(ex + 33*scale, ey + 10*scale, 10*scale, 6*scale);

                // Main rotor blades (4-blade configuration)
                const rotorRotation = (game.frameCount * 0.25) % 4;
                ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';

                if (rotorRotation < 1) {
                    // Horizontal
                    ctx.fillRect(ex - 5*scale, ey + 12*scale, 86*scale, 3*scale);
                } else if (rotorRotation < 2) {
                    // Diagonal 1
                    ctx.fillRect(ex + 15*scale, ey + 2*scale, 3*scale, 48*scale);
                    ctx.fillRect(ex + 50*scale, ey + 2*scale, 3*scale, 48*scale);
                } else if (rotorRotation < 3) {
                    // Vertical
                    ctx.fillRect(ex + 36*scale, ey - 8*scale, 3*scale, 56*scale);
                } else {
                    // Diagonal 2
                    ctx.fillRect(ex + 10*scale, ey + 2*scale, 3*scale, 48*scale);
                    ctx.fillRect(ex + 55*scale, ey + 2*scale, 3*scale, 48*scale);
                }

                // Rotor blur effect (motion blur)
                ctx.fillStyle = 'rgba(100, 100, 100, 0.15)';
                ctx.fillRect(ex - 5*scale, ey + 8*scale, 86*scale, 10*scale);

                ctx.restore();
                return;
            }

            // Different werewolf types - bigger and more menacing
            let furColor, eyeColor, chestColor, muscleTone;
            if (enemy.type === 'alpha') {
                furColor = '#3A3A3A'; // Dark gray alpha
                eyeColor = '#FF0000';
                chestColor = '#696969';
                muscleTone = '#2A2A2A';
            } else if (enemy.type === 'warrior') {
                furColor = '#5C4033'; // Brown warrior
                eyeColor = '#FF6600';
                chestColor = '#8B7355';
                muscleTone = '#4A3526';
            } else {
                furColor = '#1A1A1A'; // Black beast
                eyeColor = '#FFFF00';
                chestColor = '#3A3A3A';
                muscleTone = '#0A0A0A';
            }

            // BACK LEG (running animation)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 15, ey + 70 + legOffset, 12, 30);
            // Foot
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 12, ey + 95 + legOffset, 18, 5);

            // TAIL
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 48, ey + 45, 8, 15);
            ctx.fillRect(ex + 50, ey + 60, 6, 12);

            // BODY (muscular torso)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 10, ey + 40, 40, 35);

            // Muscle definition
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 12, ey + 42, 10, 30);
            ctx.fillRect(ex + 38, ey + 42, 10, 30);

            // CHEST (lighter fur, facing left)
            ctx.fillStyle = chestColor;
            ctx.fillRect(ex + 8, ey + 45, 20, 25);

            // SHOULDERS (broad and muscular)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 5, ey + 40, 15, 12);
            ctx.fillRect(ex + 40, ey + 40, 15, 12);

            // LEFT ARM (reaching forward aggressively)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 5, ey + 52, 10, 25);
            ctx.fillRect(ex + 3, ey + 77, 8, 15);
            // Claws
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(ex + 1, ey + 90, 3, 5);
            ctx.fillRect(ex + 5, ey + 90, 3, 5);
            ctx.fillRect(ex + 9, ey + 90, 3, 5);

            // RIGHT ARM
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 42, ey + 52, 10, 25);
            ctx.fillRect(ex + 44, ey + 77, 8, 15);
            // Claws
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(ex + 44, ey + 90, 3, 5);
            ctx.fillRect(ex + 48, ey + 90, 3, 5);
            ctx.fillRect(ex + 52, ey + 90, 3, 5);

            // NECK
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 18, ey + 30, 20, 12);

            // HEAD (large wolf head, facing LEFT toward pig)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 8, ey + 10, 35, 25);

            // Snout/Muzzle (pointing left)
            ctx.fillStyle = chestColor;
            ctx.fillRect(ex + 3, ey + 18, 15, 14);

            // Nose (wet and black)
            ctx.fillStyle = '#000000';
            ctx.fillRect(ex + 2, ey + 20, 4, 5);

            // Mouth (open with fangs)
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(ex + 4, ey + 26, 10, 5);

            // FANGS (threatening)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(ex + 5, ey + 26, 2, 6);
            ctx.fillRect(ex + 8, ey + 26, 2, 6);
            ctx.fillRect(ex + 11, ey + 26, 2, 6);
            // Bottom fangs
            ctx.fillRect(ex + 6, ey + 29, 2, 3);
            ctx.fillRect(ex + 10, ey + 29, 2, 3);

            // EYES (glowing, menacing, looking LEFT)
            ctx.fillStyle = eyeColor;
            ctx.fillRect(ex + 15, ey + 15, 5, 5);
            ctx.fillRect(ex + 24, ey + 15, 5, 5);
            // Pupils
            ctx.fillStyle = '#000000';
            ctx.fillRect(ex + 16, ey + 16, 2, 3);
            ctx.fillRect(ex + 25, ey + 16, 2, 3);

            // EARS (pointed, alert)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 12, ey + 8, 8, 5);
            ctx.fillRect(ex + 13, ey + 5, 6, 4);
            ctx.fillRect(ex + 30, ey + 8, 8, 5);
            ctx.fillRect(ex + 31, ey + 5, 6, 4);
            // Inner ear
            ctx.fillStyle = chestColor;
            ctx.fillRect(ex + 14, ey + 9, 4, 3);
            ctx.fillRect(ex + 32, ey + 9, 4, 3);

            // FRONT LEG (running animation)
            ctx.fillStyle = furColor;
            ctx.fillRect(ex + 30, ey + 70 - legOffset, 12, 30);
            // Foot
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 27, ey + 95 - legOffset, 18, 5);

            // SCARS (battle-hardened)
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(ex + 20, ey + 14, 10, 2);
            ctx.fillRect(ex + 22, ey + 16, 8, 2);
            ctx.fillRect(ex + 15, ey + 50, 12, 2);
            ctx.fillRect(ex + 35, ey + 55, 10, 2);

            // Spine ridge (aggressive posture)
            ctx.fillStyle = muscleTone;
            ctx.fillRect(ex + 45, ey + 35, 3, 8);
            ctx.fillRect(ex + 45, ey + 45, 3, 8);

            ctx.restore();
        }

        // Draw obstacle
        function drawObstacle(obstacle) {
            if (obstacle.type === 'crate') {
                // Wooden crate
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.beginPath();
                ctx.moveTo(obstacle.x, obstacle.y);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                ctx.moveTo(obstacle.x + obstacle.width, obstacle.y);
                ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                ctx.stroke();
            } else if (obstacle.type === 'barrel') {
                // Metal barrel
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5);
                ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 5, obstacle.width, 5);
            } else if (obstacle.type === 'tire') {
                // Tire
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(obstacle.x + 5, obstacle.y + 5, obstacle.width - 10, obstacle.height - 10);
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x + 8, obstacle.y + 8, obstacle.width - 16, obstacle.height - 16);
            } else if (obstacle.type === 'cone') {
                // Traffic cone
                ctx.fillStyle = '#FF6600';
                ctx.beginPath();
                ctx.moveTo(obstacle.x + obstacle.width / 2, obstacle.y);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                ctx.closePath();
                ctx.fill();
                // White stripes
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(obstacle.x + 3, obstacle.y + 10, obstacle.width - 6, 3);
                ctx.fillRect(obstacle.x + 5, obstacle.y + 18, obstacle.width - 10, 3);
                // Base
                ctx.fillStyle = '#333333';
                ctx.fillRect(obstacle.x - 2, obstacle.y + obstacle.height, obstacle.width + 4, 3);
            } else if (obstacle.type === 'trash') {
                // Trash can
                ctx.fillStyle = '#2F4F2F';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5); // Lid
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x + 3, obstacle.y + 8, obstacle.width - 6, 3);
                ctx.fillRect(obstacle.x + 3, obstacle.y + 18, obstacle.width - 6, 3);
                // Trash overflow
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(obstacle.x + 5, obstacle.y - 5, 8, 5);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x + 15, obstacle.y - 3, 6, 3);
            } else if (obstacle.type === 'fence') {
                // Wooden fence
                ctx.fillStyle = '#654321';
                // Horizontal planks
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(obstacle.x, obstacle.y + i * 15, obstacle.width, 10);
                }
                // Vertical posts
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x + 2, obstacle.y, 8, obstacle.height);
                ctx.fillRect(obstacle.x + obstacle.width - 10, obstacle.y, 8, obstacle.height);
            } else if (obstacle.type === 'hydrant') {
                // Fire hydrant
                ctx.fillStyle = '#DC143C'; // Red
                ctx.fillRect(obstacle.x + 5, obstacle.y + 5, obstacle.width - 10, obstacle.height - 10);
                // Top cap
                ctx.fillStyle = '#B22222';
                ctx.fillRect(obstacle.x + 3, obstacle.y, obstacle.width - 6, 8);
                // Side nozzles
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.fillRect(obstacle.x, obstacle.y + 15, 5, 8);
                ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y + 15, 5, 8);
                // Base
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(obstacle.x + 2, obstacle.y + obstacle.height - 5, obstacle.width - 4, 5);
            } else if (obstacle.type === 'mailbox') {
                // Mailbox
                ctx.fillStyle = '#4169E1'; // Royal blue
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height - 15);
                // Post
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x + obstacle.width / 2 - 3, obstacle.y + obstacle.height - 15, 6, 15);
                // Flag
                ctx.fillStyle = '#DC143C';
                ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y + 5, 8, 5);
                // Door line
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x + 3, obstacle.y + 3, obstacle.width - 6, obstacle.height - 21);
            } else if (obstacle.type === 'dumpster') {
                // Large dumpster
                ctx.fillStyle = '#2F4F2F'; // Dark green
                ctx.fillRect(obstacle.x, obstacle.y + 5, obstacle.width, obstacle.height - 10);
                // Lid (slightly open)
                ctx.fillStyle = '#1C4C1C';
                ctx.fillRect(obstacle.x + 5, obstacle.y, obstacle.width - 10, 8);
                // Wheels
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(obstacle.x + 5, obstacle.y + obstacle.height - 5, 8, 8);
                ctx.fillRect(obstacle.x + obstacle.width - 13, obstacle.y + obstacle.height - 5, 8, 8);
                // Handles
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(obstacle.x + 2, obstacle.y + 15, 4, 15);
                ctx.fillRect(obstacle.x + obstacle.width - 6, obstacle.y + 15, 4, 15);
            } else if (obstacle.type === 'sign') {
                // Street sign
                ctx.fillStyle = '#DC143C'; // Red sign
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 25);
                // Stop text (smaller and centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('STOP', obstacle.x + obstacle.width / 2, obstacle.y + 16);
                ctx.textAlign = 'left'; // Reset text align
                // Post
                ctx.fillStyle = '#808080';
                ctx.fillRect(obstacle.x + obstacle.width / 2 - 3, obstacle.y + 25, 6, 25);
            } else if (obstacle.type === 'car') {
                // Pixel art regular sedan car (2.5x scale)
                const carX = obstacle.x;
                const carY = obstacle.y;

                // Color variants: 0=Red, 1=Blue, 2=Black
                const colorVariant = obstacle.colorVariant || 0;
                let bodyColor, bodyDark, bodyLight;

                if (colorVariant === 0) {
                    // Red car
                    bodyColor = '#CC0000';
                    bodyDark = '#8B0000';
                    bodyLight = '#FF3333';
                } else if (colorVariant === 1) {
                    // Blue car
                    bodyColor = '#0066CC';
                    bodyDark = '#003D7A';
                    bodyLight = '#3399FF';
                } else {
                    // Black car
                    bodyColor = '#2A2A2A';
                    bodyDark = '#0A0A0A';
                    bodyLight = '#4A4A4A';
                }

                // Main body (scaled 2.5x from original 60x20)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(carX + 25, carY + 37, 150, 50);

                // Body highlights
                ctx.fillStyle = bodyLight;
                ctx.fillRect(carX + 30, carY + 40, 140, 8);

                // Body shadows
                ctx.fillStyle = bodyDark;
                ctx.fillRect(carX + 25, carY + 75, 150, 12);

                // Roof/cabin (scaled 2.5x from 35x15)
                ctx.fillStyle = bodyDark;
                ctx.fillRect(carX + 50, carY + 20, 87, 37);

                // Hood (scaled 2.5x from 15x12)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(carX + 137, carY + 45, 37, 30);

                // Hood highlight
                ctx.fillStyle = bodyLight;
                ctx.fillRect(carX + 140, carY + 48, 30, 6);

                // Trunk (scaled 2.5x from 10x12)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(carX + 25, carY + 45, 25, 30);

                // Windows - front (scaled 2.5x from 12x10)
                ctx.fillStyle = '#1A3A5C';
                ctx.fillRect(carX + 55, carY + 25, 30, 25);

                // Windows - rear (scaled 2.5x from 12x10)
                ctx.fillStyle = '#1A3A5C';
                ctx.fillRect(carX + 100, carY + 25, 30, 25);

                // Window highlights
                ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';
                ctx.fillRect(carX + 58, carY + 27, 8, 20);
                ctx.fillRect(carX + 103, carY + 27, 8, 20);

                // Wheels - rear (scaled 2.5x from 12x10)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(carX + 37, carY + 87, 30, 25);

                // Wheels - front (scaled 2.5x from 12x10)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(carX + 132, carY + 87, 30, 25);

                // Wheel rims - rear (scaled 2.5x from 6x4)
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(carX + 45, carY + 95, 15, 10);

                // Wheel rims - front (scaled 2.5x from 6x4)
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(carX + 140, carY + 95, 15, 10);

                // Headlights (scaled 2.5x from 3x4)
                ctx.fillStyle = '#FFFFE0';
                ctx.fillRect(carX + 170, carY + 50, 7, 10);
                ctx.fillRect(carX + 170, carY + 65, 7, 10);

                // Headlight glow
                ctx.fillStyle = 'rgba(255, 255, 200, 0.5)';
                ctx.fillRect(carX + 177, carY + 52, 5, 6);
                ctx.fillRect(carX + 177, carY + 67, 5, 6);

                // Taillights (scaled 2.5x from 2x3)
                ctx.fillStyle = '#DC143C';
                ctx.fillRect(carX + 22, carY + 50, 5, 7);
                ctx.fillRect(carX + 22, carY + 67, 5, 7);

                // License plate - rear (scaled 2.5x from 8x3)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(carX + 32, carY + 80, 20, 7);

                // License plate - front (scaled 2.5x)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(carX + 165, carY + 80, 12, 7);

                // Side mirror
                ctx.fillStyle = bodyDark;
                ctx.fillRect(carX + 48, carY + 32, 5, 8);

                // Door line detail
                ctx.fillStyle = bodyDark;
                ctx.fillRect(carX + 85, carY + 45, 3, 35);

                // Chrome bumper - front
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(carX + 175, carY + 80, 5, 7);

                // Chrome bumper - rear
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(carX + 20, carY + 80, 5, 7);
            }
        }

        // Draw basement entrance
        function drawBasementEntrance(entrance) {
            ctx.save();

            // Stairs going down
            ctx.fillStyle = '#3C3C3C'; // Dark gray concrete
            ctx.fillRect(entrance.x, entrance.y, entrance.width, entrance.height);

            // Steps (3-4 visible steps)
            ctx.fillStyle = '#2C2C2C';
            for (let i = 0; i < 4; i++) {
                const stepY = entrance.y + i * 25;
                ctx.fillRect(entrance.x + 10, stepY, entrance.width - 20, 20);
                // Step edge highlight
                ctx.fillStyle = '#4C4C4C';
                ctx.fillRect(entrance.x + 10, stepY, entrance.width - 20, 3);
                ctx.fillStyle = '#2C2C2C';
            }

            // Side walls
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(entrance.x, entrance.y, 10, entrance.height); // Left wall
            ctx.fillRect(entrance.x + entrance.width - 10, entrance.y, 10, entrance.height); // Right wall

            // Door at bottom (partially visible)
            ctx.fillStyle = '#654321'; // Brown wooden door
            ctx.fillRect(entrance.x + 20, entrance.y + 85, 80, 25);

            // Door handle
            ctx.fillStyle = '#FFD700'; // Gold handle
            ctx.fillRect(entrance.x + 85, entrance.y + 95, 8, 5);

            // Sign above entrance
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(entrance.x + 10, entrance.y - 30, entrance.width - 20, 25);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('üè™ SHOP', entrance.x + entrance.width / 2, entrance.y - 10);

            ctx.restore();
        }

        // Draw street lamp (2.6x taller - 30% increase from 2x, wider)
        function drawStreetLamp(lamp) {
            const centerX = lamp.x + lamp.width / 2;

            // Lamp post (2.6x taller - 30% increase)
            ctx.fillStyle = '#2C2C2C'; // Dark gray
            ctx.fillRect(centerX - 8, lamp.y + 45, 16, 215); // Vertical post (thicker and taller: 165*1.3=214.5)

            // Top bracket (connects lamp to post)
            ctx.fillRect(centerX - 19, lamp.y + 39, 19, 10); // Horizontal bracket (scaled 1.3x)

            // Lamp housing (larger - 1.3x)
            ctx.fillStyle = '#1C1C1C'; // Very dark gray/black
            ctx.fillRect(centerX - 26, lamp.y, 52, 45); // Lamp box (40*1.3=52, 35*1.3=45)

            // Lamp glass/bulb
            if (game.isNight) {
                // Soft, smooth multi-layer glow effect (wider and more diffused)
                // Outermost glow layer (very soft and wide) - 50% wider
                const outerGradient = ctx.createRadialGradient(centerX, lamp.y + 22, 0, centerX, lamp.y + 22, 120);
                outerGradient.addColorStop(0, 'rgba(255, 215, 0, 0.2)'); // Increased opacity
                outerGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.12)'); // Increased opacity
                outerGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.05)');
                outerGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = outerGradient;
                ctx.fillRect(centerX - 120, lamp.y - 98, 240, 240);

                // Middle glow layer (wider)
                const middleGradient = ctx.createRadialGradient(centerX, lamp.y + 22, 0, centerX, lamp.y + 22, 75);
                middleGradient.addColorStop(0, 'rgba(255, 215, 0, 0.35)'); // Increased opacity
                middleGradient.addColorStop(0.4, 'rgba(255, 215, 0, 0.2)'); // Increased opacity
                middleGradient.addColorStop(0.7, 'rgba(255, 215, 0, 0.08)');
                middleGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = middleGradient;
                ctx.fillRect(centerX - 75, lamp.y - 53, 150, 150);

                // Inner glow (bright core)
                const innerGradient = ctx.createRadialGradient(centerX, lamp.y + 22, 0, centerX, lamp.y + 22, 33);
                innerGradient.addColorStop(0, 'rgba(255, 235, 150, 0.65)');
                innerGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.45)');
                innerGradient.addColorStop(1, 'rgba(255, 215, 0, 0.15)');
                ctx.fillStyle = innerGradient;
                ctx.fillRect(centerX - 33, lamp.y - 11, 66, 66);

                // Yellow light bulb (bright center) - scaled 1.3x
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(centerX - 21, lamp.y + 5, 42, 36);

                // Light beam downward (soft gradient cone) - wider and more diffused
                const beamGradient = ctx.createLinearGradient(centerX, lamp.y + 45, centerX, lamp.y + 273);
                beamGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)'); // Increased opacity
                beamGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.18)'); // Increased opacity
                beamGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.08)');
                beamGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = beamGradient;
                // Cone shape (much wider at bottom for more diffusion)
                ctx.beginPath();
                ctx.moveTo(centerX - 26, lamp.y + 45);
                ctx.lineTo(centerX - 110, lamp.y + 273); // Wider spread (70*1.5=105, rounded to 110)
                ctx.lineTo(centerX + 110, lamp.y + 273);
                ctx.lineTo(centerX + 26, lamp.y + 45);
                ctx.closePath();
                ctx.fill();
            } else {
                // Off during day (dark glass, scaled 1.3x)
                ctx.fillStyle = '#4A4A4A'; // Dark gray glass
                ctx.fillRect(centerX - 21, lamp.y + 5, 42, 36);
            }

            // Base (wider and lower)
            ctx.fillStyle = '#3C3C3C';
            ctx.fillRect(centerX - 19, lamp.y + 260, 38, 13); // Scaled 1.3x
        }

        // Draw merchant character with cloak and legs (based on crouton.png mask)
        function drawMerchant(x, y) {
            ctx.save();

            // Duck body (white feathers)
            ctx.fillStyle = '#FFFFFF'; // White
            // Main body (plump, round)
            ctx.fillRect(x - 35, y + 70, 70, 80); // Main body

            // Body shading (light gray for volume)
            ctx.fillStyle = '#E8E8E8';
            ctx.fillRect(x + 20, y + 75, 15, 70); // Right side shading

            // Chest/belly (slightly rounder)
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(x - 30, y + 80, 60, 60);

            // Wings (folded on sides)
            ctx.fillStyle = '#FFFFFF';
            // Left wing
            ctx.fillRect(x - 40, y + 85, 12, 50);
            ctx.fillRect(x - 45, y + 90, 8, 40);
            // Right wing
            ctx.fillRect(x + 28, y + 85, 12, 50);
            ctx.fillRect(x + 37, y + 90, 8, 40);

            // Wing feather details
            ctx.fillStyle = '#D0D0D0';
            // Left wing feathers
            ctx.fillRect(x - 42, y + 95, 6, 8);
            ctx.fillRect(x - 42, y + 108, 6, 8);
            ctx.fillRect(x - 42, y + 121, 6, 8);
            // Right wing feathers
            ctx.fillRect(x + 36, y + 95, 6, 8);
            ctx.fillRect(x + 36, y + 108, 6, 8);
            ctx.fillRect(x + 36, y + 121, 6, 8);

            // Duck legs (orange webbed feet)
            ctx.fillStyle = '#FF8C00'; // Dark orange
            // Left leg
            ctx.fillRect(x - 18, y + 145, 10, 35);
            // Right leg
            ctx.fillRect(x + 8, y + 145, 10, 35);

            // Webbed feet
            ctx.fillStyle = '#FFA500'; // Orange
            // Left foot
            ctx.fillRect(x - 22, y + 178, 18, 8);
            ctx.fillRect(x - 20, y + 184, 4, 6); // Toe 1
            ctx.fillRect(x - 14, y + 184, 4, 6); // Toe 2
            ctx.fillRect(x - 8, y + 184, 4, 6); // Toe 3
            // Right foot
            ctx.fillRect(x + 4, y + 178, 18, 8);
            ctx.fillRect(x + 6, y + 184, 4, 6); // Toe 1
            ctx.fillRect(x + 12, y + 184, 4, 6); // Toe 2
            ctx.fillRect(x + 18, y + 184, 4, 6); // Toe 3

            // Neck (white, connecting to head)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x - 20, y + 50, 40, 25);

            // Neck shading
            ctx.fillStyle = '#E8E8E8';
            ctx.fillRect(x + 10, y + 52, 10, 20);

            // Head - use actual crouton.png image (larger and properly positioned)
            if (merchantHeadImg.complete) {
                // Draw the image centered, scaled larger to match body
                const headWidth = 110;
                const headHeight = 110;
                ctx.drawImage(merchantHeadImg, x - headWidth/2 - 5, y - 35, headWidth, headHeight); // Shifted 5px left
            }

            ctx.restore();
        }

        // Draw basement scene
        function drawBasement() {
            // Dark basement background
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Brick walls (darker)
            ctx.fillStyle = '#1a1a1a';
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 20; col++) {
                    const bx = col * 60 + (row % 2) * 30;
                    const by = row * 50;
                    ctx.fillRect(bx, by, 55, 45);
                }
            }

            // Brick grout lines
            ctx.strokeStyle = '#0a0a0a';
            ctx.lineWidth = 2;
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 20; col++) {
                    const bx = col * 60 + (row % 2) * 30;
                    const by = row * 50;
                    ctx.strokeRect(bx, by, 55, 45);
                }
            }

            // Stone floor
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(0, 450, canvas.width, 50);

            // Floor tile lines
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            for (let i = 0; i < canvas.width; i += 60) {
                ctx.beginPath();
                ctx.moveTo(i, 450);
                ctx.lineTo(i, 500);
                ctx.stroke();
            }

            // Hanging lamp (dim yellow light source)
            const lampX = canvas.width / 2;
            const lampY = 100;

            // Lamp chain
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lampX, 0);
            ctx.lineTo(lampX, lampY - 20);
            ctx.stroke();

            // Lamp body
            ctx.fillStyle = '#3C3C3C';
            ctx.fillRect(lampX - 20, lampY - 20, 40, 15);

            // Lamp light (yellow glow)
            const lampGradient = ctx.createRadialGradient(lampX, lampY, 0, lampX, lampY, 150);
            lampGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
            lampGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.1)');
            lampGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = lampGradient;
            ctx.fillRect(0, 0, canvas.width, 400);

            // Actual light bulb
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(lampX - 8, lampY - 5, 16, 20);
        }

        // Draw shop counter
        function drawShopCounter(counter) {
            // Gray metal board on wall
            ctx.fillStyle = '#555555'; // Medium gray
            ctx.fillRect(counter.x, counter.y, counter.width, counter.height);

            // Metal texture (horizontal lines)
            ctx.fillStyle = '#3A3A3A';
            for (let i = 0; i < 8; i++) {
                const lineY = counter.y + i * (counter.height / 8);
                ctx.fillRect(counter.x, lineY, counter.width, 2);
            }

            // Board edge/border (lighter gray frame)
            ctx.strokeStyle = '#777777';
            ctx.lineWidth = 6;
            ctx.strokeRect(counter.x, counter.y, counter.width, counter.height);

            // Nails/screws in corners
            ctx.fillStyle = '#1C1C1C';
            const nailSize = 8;
            // Top left
            ctx.fillRect(counter.x + 10, counter.y + 10, nailSize, nailSize);
            // Top right
            ctx.fillRect(counter.x + counter.width - 18, counter.y + 10, nailSize, nailSize);
            // Bottom left
            ctx.fillRect(counter.x + 10, counter.y + counter.height - 18, nailSize, nailSize);
            // Bottom right
            ctx.fillRect(counter.x + counter.width - 18, counter.y + counter.height - 18, nailSize, nailSize);

            // Label on top of board
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            // Adjust text position for equipment board (shift left)
            const textOffset = counter.label === 'üõ°Ô∏è EQUIPMENT' ? -20 : 0;
            ctx.fillText(counter.label, counter.x + counter.width / 2 + textOffset, counter.y + 35);
        }

        // Draw SuperUSD safe
        function drawSuperUsdSafe() {
            const safe = shopCounters.superusd;
            const safeX = safe.safeX;
            const safeY = safe.safeY;
            const safeWidth = safe.safeWidth;
            const safeHeight = safe.safeHeight;

            // Label above safe with arrow
            ctx.fillStyle = '#9CE500';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SuperUSD', safeX + safeWidth / 2, safe.labelY);
            ctx.fillText('‚Üì', safeX + safeWidth / 2, safe.labelY + 20);

            // Safe body (dark metallic gray)
            ctx.fillStyle = '#2A2A2A';
            ctx.fillRect(safeX, safeY, safeWidth, safeHeight);

            // Safe border (3D effect)
            ctx.strokeStyle = '#5A5A5A';
            ctx.lineWidth = 5;
            ctx.strokeRect(safeX, safeY, safeWidth, safeHeight);

            // Inner border (darker)
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = 2;
            ctx.strokeRect(safeX + 5, safeY + 5, safeWidth - 10, safeHeight - 10);

            // Metal rivets (screws on corners)
            ctx.fillStyle = '#6A6A6A';
            const rivetSize = 6;
            // Top corners
            ctx.fillRect(safeX + 8, safeY + 8, rivetSize, rivetSize);
            ctx.fillRect(safeX + safeWidth - 14, safeY + 8, rivetSize, rivetSize);
            // Bottom corners
            ctx.fillRect(safeX + 8, safeY + safeHeight - 14, rivetSize, rivetSize);
            ctx.fillRect(safeX + safeWidth - 14, safeY + safeHeight - 14, rivetSize, rivetSize);

            // Original SVG logo in center
            const logoSize = 60;
            const logoX = safeX + (safeWidth - logoSize) / 2;
            const logoY = safeY + 15;

            if (superUsdLogo.complete && superUsdLogo.naturalWidth > 0) {
                ctx.drawImage(superUsdLogo, logoX, logoY, logoSize, logoSize);
            } else {
                // Fallback if logo not loaded - draw green circle
                ctx.fillStyle = '#9CE500';
                ctx.beginPath();
                ctx.arc(logoX + logoSize / 2, logoY + logoSize / 2, logoSize / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#254544';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('$', logoX + logoSize / 2, logoY + logoSize / 2 + 8);
            }

            // Combination lock dial (below logo)
            const lockY = safeY + safeHeight - 35;
            const lockX = safeX + safeWidth / 2;

            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(lockX, lockY, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#6A6A6A';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Lock handle (golden)
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(lockX - 5, lockY - 2, 10, 4);

            // Lock notches
            ctx.strokeStyle = '#8A8A8A';
            ctx.lineWidth = 1;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x1 = lockX + Math.cos(angle) * 12;
                const y1 = lockY + Math.sin(angle) * 12;
                const x2 = lockX + Math.cos(angle) * 15;
                const y2 = lockY + Math.sin(angle) * 15;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Payout indicator (glowing green badge if there's pending payout)
            if (game.pendingPayout > 0) {
                // Glowing badge in top-right corner
                const badgeX = safeX + safeWidth - 15;
                const badgeY = safeY + 15;
                const badgeRadius = 12;

                // Pulsing glow effect
                const pulseIntensity = 0.5 + Math.sin(game.frameCount * 0.1) * 0.3;
                ctx.shadowColor = '#9CE500';
                ctx.shadowBlur = 20 * pulseIntensity;

                // Green circle
                ctx.fillStyle = '#9CE500';
                ctx.beginPath();
                ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Dollar sign
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('$', badgeX, badgeY + 6);

                // Exclamation mark animation
                const offset = Math.sin(game.frameCount * 0.15) * 3;
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 20px Courier New';
                ctx.fillText('!', badgeX + 18, badgeY - 8 + offset);
            }

            // Hover effect
            const mouseInSafe = game.mouseX >= safeX && game.mouseX <= safeX + safeWidth &&
                               game.mouseY >= safeY && game.mouseY <= safeY + safeHeight;

            if (mouseInSafe && game.inShop) {
                ctx.strokeStyle = '#9CE500';
                ctx.lineWidth = 4;
                ctx.strokeRect(safeX - 5, safeY - 5, safeWidth + 10, safeHeight + 10);
                ctx.shadowColor = '#9CE500';
                ctx.shadowBlur = 20;

                // Tooltip (to the left of safe)
                const tooltipX = safeX - 170;
                const tooltipY = safeY + 20;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(tooltipX, tooltipY, 160, 90);
                ctx.strokeStyle = '#9CE500';
                ctx.lineWidth = 3;
                ctx.strokeRect(tooltipX, tooltipY, 160, 90);

                ctx.fillStyle = '#9CE500';
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText('Investment Safe', tooltipX + 10, tooltipY + 25);
                ctx.fillStyle = '#FFB6C1';
                ctx.font = '13px Courier New';
                ctx.fillText('Earn 1.5x return', tooltipX + 10, tooltipY + 48);
                ctx.fillText('in next shop!', tooltipX + 10, tooltipY + 65);
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 12px Courier New';
                ctx.fillText('Click to invest', tooltipX + 10, tooltipY + 82);
            }

            ctx.shadowBlur = 0;
        }

        // Draw weapon on counter (using exact game models)
        function drawWeaponOnCounter(weaponId, x, y, width, height, isHovered) {
            ctx.save();

            // Highlight if hovered
            if (isHovered) {
                ctx.strokeStyle = '#FF69B4'; // Pink highlight
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 5, y - 5, width + 10, height + 10);

                // Glow effect
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }

            // Center the weapon in the bounding box
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            ctx.translate(centerX, centerY);

            // Draw weapon based on ID (exact game models) - centered
            if (weaponId === 'colt') {
                // Colt M1911 - compact pistol (exact copy from drawPig)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-12, -3, 18, 6); // Barrel
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-9, -1, 3, 8); // Magazine
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-7, 0, 6, 6); // Grip
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(4, -4, 2, 8); // Front sight
            } else if (weaponId === 'shotgun') {
                // Pump Shotgun - longer, thicker
                ctx.fillStyle = '#654321';
                ctx.fillRect(-14, -4, 28, 8); // Main body (wood)
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-14, -2, 28, 4); // Barrel (metal)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-4, 1, 8, 6); // Pump handle
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(4, 0, 4, 6); // Trigger area
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(12, -3, 2, 6); // Front sight
            } else if (weaponId === 'tommy') {
                // Tommy Gun - iconic with drum mag
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-12, -4, 25, 6); // Main barrel

                // Round drum magazine (iconic)
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-6, -2, 12, 12); // Drum
                ctx.fillRect(-4, -4, 8, 16); // Extended drum

                // Front sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(11, -6, 3, 10);

                // Wooden grip
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-8, 2, 6, 8);

                // Foregrip
                ctx.fillStyle = '#654321';
                ctx.fillRect(2, 2, 4, 6);
            } else if (weaponId === 'sniper') {
                // Sniper Rifle - long, precise, with scope
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-17, -3, 35, 6); // Main barrel (very long)

                // Scope on top
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-6, -7, 12, 4); // Scope body
                ctx.fillStyle = '#87CEEB'; // Light blue lens
                ctx.fillRect(-5, -6, 3, 2);
                ctx.fillRect(2, -6, 3, 2);

                // Stock
                ctx.fillStyle = '#654321'; // Wood
                ctx.fillRect(-12, 1, 10, 6);

                // Bipod
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(8, 3, 2, 6);
                ctx.fillRect(13, 3, 2, 6);
            } else if (weaponId === 'ak47') {
                // AK-47 - realistic iconic design (centered for shop display)
                // Wooden stock
                ctx.fillStyle = '#654321';
                ctx.fillRect(-18, -1, 10, 5); // Stock base

                // Main receiver/body
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(-11, -4, 24, 8); // Main receiver

                // Dust cover (top)
                ctx.fillStyle = '#2C2C2C';
                ctx.fillRect(-9, -5, 20, 2); // Dust cover

                // Rear sight
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(-1, -7, 3, 3); // Rear sight

                // Barrel
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(11, -2, 16, 4); // Barrel

                // Gas tube
                ctx.fillStyle = '#3A3A3A';
                ctx.fillRect(11, -4, 14, 2); // Gas tube

                // Wooden handguard
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(11, 2, 10, 2); // Lower handguard

                // Front sight block
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(23, -4, 2, 6); // Front sight block
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(23, -4, 2, 2); // Sight post

                // Slant muzzle brake
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(25, -3, 2, 5); // Muzzle brake
                ctx.fillRect(26, -2, 2, 3); // Brake cut

                // Curved magazine (iconic)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(-2, 4, 7, 3); // Top of mag
                ctx.fillRect(-1, 7, 6, 8); // Curved body
                ctx.fillRect(0, 15, 4, 2); // Bottom curve

                // Magazine lips (brass)
                ctx.fillStyle = '#B8860B';
                ctx.fillRect(-1, 4, 5, 1); // Brass showing

                // Pistol grip
                ctx.fillStyle = '#654321';
                ctx.fillRect(-8, 4, 4, 6); // Grip
                ctx.fillRect(-9, 10, 5, 3); // Grip bottom

                // Trigger guard
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-4, 3, 4, 1); // Guard top
                ctx.fillRect(-4, 7, 4, 1); // Guard bottom

                // Selector switch (red)
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(-10, 0, 2, 3); // Selector lever
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw armor on counter (pixel-style tactical vest)
        function drawArmorOnCounter(x, y, width, height, isHovered) {
            ctx.save();

            if (isHovered) {
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 5, y - 5, width + 10, height + 10);
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }

            // Center the armor in the bounding box
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            ctx.translate(centerX, centerY);

            // Tactical vest (pixel-style) - centered
            // Main vest body (dark gray/black)
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(-20, -15, 40, 30);

            // Armor plates (lighter gray)
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(-18, -13, 18, 12); // Left plate
            ctx.fillRect(0, -13, 18, 12); // Right plate
            ctx.fillRect(-18, 1, 36, 12); // Bottom plate

            // Kevlar texture lines (dark lines)
            ctx.fillStyle = '#1C1C1C';
            ctx.fillRect(-18, -10, 18, 2);
            ctx.fillRect(-18, -6, 18, 2);
            ctx.fillRect(0, -10, 18, 2);
            ctx.fillRect(0, -6, 18, 2);
            ctx.fillRect(-16, 5, 32, 2);
            ctx.fillRect(-16, 9, 32, 2);

            // Straps (brown)
            ctx.fillStyle = '#654321';
            ctx.fillRect(-22, -3, 4, 8); // Left strap
            ctx.fillRect(18, -3, 4, 8); // Right strap

            // Buckles (metallic)
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(-22, -1, 4, 3);
            ctx.fillRect(18, -1, 4, 3);

            // Badge/emblem (centered)
            ctx.fillStyle = '#FFD700'; // Gold badge
            ctx.fillRect(-3, 4, 6, 6);
            ctx.fillStyle = '#FF1493'; // Pink center
            ctx.fillRect(-2, 5, 4, 4);

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw health on counter
        function drawHealthOnCounter(x, y, width, height, isHovered) {
            ctx.save();

            if (isHovered) {
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 5, y - 5, width + 10, height + 10);
                ctx.shadowColor = '#FF69B4';
                ctx.shadowBlur = 15;
            }

            // Center the heart in the bounding box
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            ctx.translate(centerX, centerY);

            // Pixel-art heart - drawing pixel by pixel
            const pixelSize = 4; // Size of each pixel

            // Heart pattern (8x7 pixels)
            const heartPattern = [
                [0,1,1,0,0,1,1,0],
                [1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,0,0],
                [0,0,0,1,1,0,0,0]
            ];

            // Draw heart with gradient effect
            for (let row = 0; row < heartPattern.length; row++) {
                for (let col = 0; col < heartPattern[row].length; col++) {
                    if (heartPattern[row][col] === 1) {
                        // Main red color
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(
                            (col - 4) * pixelSize,
                            (row - 3.5) * pixelSize,
                            pixelSize,
                            pixelSize
                        );
                    }
                }
            }

            // Add highlights for depth (lighter pixels on top-left)
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(-1 * pixelSize, -2 * pixelSize, pixelSize, pixelSize);
            ctx.fillRect(0, -2 * pixelSize, pixelSize, pixelSize);
            ctx.fillRect(2 * pixelSize, -2 * pixelSize, pixelSize, pixelSize);

            // Add darker pixels for depth (bottom-right)
            ctx.fillStyle = '#CC0000';
            ctx.fillRect(-1 * pixelSize, 2 * pixelSize, pixelSize, pixelSize);
            ctx.fillRect(0, 2 * pixelSize, pixelSize, pixelSize);
            ctx.fillRect(1 * pixelSize, 2 * pixelSize, pixelSize, pixelSize);

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw item tooltip
        function drawItemTooltip(item, x, y) {
            const tooltipX = x + 80;
            const tooltipY = y - 60;
            const tooltipWidth = 200;
            const tooltipHeight = 120;

            // Tooltip background
            ctx.fillStyle = 'rgba(26, 26, 26, 0.95)';
            ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);

            // Arrow pointing to item
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(tooltipX, tooltipY + 60);
            ctx.lineTo(tooltipX - 10, tooltipY + 55);
            ctx.lineTo(tooltipX - 10, tooltipY + 65);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'left';

            let yOffset = tooltipY + 25;

            if (item.id in weapons) {
                const weapon = weapons[item.id];
                ctx.fillText(weapon.name, tooltipX + 10, yOffset);
                yOffset += 20;
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Courier New';
                ctx.fillText(`Damage: ${weapon.damage}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText(`Magazine: ${weapon.magSize}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText(`Fire Rate: ${weapon.auto ? 'Auto' : 'Semi'}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillStyle = game.ownedWeapons.includes(item.id) ? '#00FF00' : '#FFD700';
                ctx.fillText(game.ownedWeapons.includes(item.id) ? 'OWNED ‚úì' : `Price: $${weapon.price}`, tooltipX + 10, yOffset);
            } else if (item.id === 'armor') {
                ctx.fillText('Armor Vest', tooltipX + 10, yOffset);
                yOffset += 20;
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Courier New';
                ctx.fillText('+1 Protection', tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText('Absorbs damage', tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillStyle = '#FFD700';
                ctx.fillText('Price: $100', tooltipX + 10, yOffset);
            } else if (item.id === 'health') {
                ctx.fillText('Health Kit', tooltipX + 10, yOffset);
                yOffset += 20;
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Courier New';
                ctx.fillText('+1 Health', tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillText(`Current: ${game.health}/${game.maxHealth}`, tooltipX + 10, yOffset);
                yOffset += 18;
                ctx.fillStyle = game.health >= game.maxHealth ? '#FF0000' : '#FFD700';
                ctx.fillText(game.health >= game.maxHealth ? 'MAX HEALTH' : 'Price: $100', tooltipX + 10, yOffset);
            }
        }

        // Shoot bullet
        function shoot() {
            const weapon = weapons[game.weapon];

            // Check if can shoot
            if (shootCooldown <= 0 && !game.isReloading && !game.isPumping && game.currentAmmo > 0) {
                const bulletY = player.isCrouching ? player.y + 35 : player.y + 30;

                // Shoot based on weapon type - OPTIMIZED WITH POOLING
                for (let i = 0; i < weapon.bulletCount; i++) {
                    const spreadAngle = (Math.random() - 0.5) * weapon.spread;

                    // Get bullet from pool
                    const bullet = getFromPool('bullets');
                    bullet.x = player.x + 70;
                    bullet.y = bulletY + spreadAngle;
                    bullet.width = game.weapon === 'shotgun' ? 6 : (game.weapon === 'colt' ? 8 : 10);
                    bullet.height = 3;
                    bullet.speed = weapon.bulletSpeed;
                    bullet.damage = weapon.damage;
                    bullet.angle = spreadAngle * 0.05;

                    bullets.push(bullet);
                }

                game.currentAmmo--;
                shootCooldown = weapon.fireRate;
                game.muzzleFlashSize = 8; // Flash animation

                // Play weapon sound
                playShootSound(game.weapon);

                // Shotgun needs pumping after each shot
                if (game.weapon === 'shotgun') {
                    game.isPumping = true;
                    game.pumpProgress = weapon.pumpTime;
                }

                // Auto reload when empty
                if (game.currentAmmo === 0) {
                    startReload();
                }
            }
        }

        // Start reload
        function startReload() {
            const weapon = weapons[game.weapon];
            if (!game.isReloading && game.currentAmmo < weapon.magSize) {
                game.isReloading = true;
                game.reloadProgress = weapon.reloadTime;
            }
        }

        // Update game
        function update() {
            // Handle cutscene
            if (game.cutsceneActive) {
                game.cutsceneTimer++;

                // Phase 0: Pig enters basement
                if (game.cutscenePhase === 0) {
                    game.pigX += 2; // Move pig right (slower, smoother - was 5)
                    if (game.pigX >= 70) { // Stop at final position (70)
                        game.cutscenePhase = 1;
                        game.cutsceneTimer = 0;
                        // Show merchant dialog
                        document.getElementById('merchantDialog').style.display = 'block';
                    }
                }
                // Phase 1: Dialog shown, waiting for user response
                // (handled by button click events)

                return; // Don't update game while cutscene is active
            }

            if (!game.running) {
                // Handle countdown
                if (game.countdown > 0) {
                    game.countdown--;
                    if (game.countdown === 0) {
                        game.running = true;
                        // Resume background music after countdown
                        // playBackgroundMusic(); // Music disabled
                    }
                }
                return;
            }

            game.frameCount++;
            shootCooldown = Math.max(0, shootCooldown - 1);
            game.muzzleFlashSize = Math.max(0, game.muzzleFlashSize - 1);

            // Handle reload
            if (game.isReloading) {
                game.reloadProgress--;
                if (game.reloadProgress <= 0) {
                    game.isReloading = false;
                    game.currentAmmo = weapons[game.weapon].magSize;
                }
            }

            // Handle pump action (shotgun)
            if (game.isPumping) {
                game.pumpProgress--;
                if (game.pumpProgress <= 0) {
                    game.isPumping = false;
                }
            }

            // Manual reload
            if ((keys['r'] || keys['R']) && !game.isReloading && !document.getElementById('shop').classList.contains('active')) {
                startReload();
            }

            // Shooting
            const weapon = weapons[game.weapon];
            const shootPressed = mouseDown;

            // Shooting (disabled during auto-running to basement)
            if (!game.autoRunning && shootPressed && !document.getElementById('shop').classList.contains('active')) {
                // Auto or semi-auto
                if (weapon.auto) {
                    shoot(); // Tommy Gun - full auto
                } else {
                    // Semi-auto - only shoot on new press
                    if (!game.lastShot) {
                        shoot();
                    }
                }
                game.lastShot = true;
            } else {
                game.lastShot = false;
            }

            // Player physics (disabled during auto-running to basement)
            if (!game.autoRunning) {
                if (keys[' '] && !player.isJumping && !player.isCrouching) {
                    player.velocityY = player.jumpPower;
                    player.isJumping = true;
                }
            }

            player.isCrouching = false; // Crouch removed

            player.velocityY += player.gravity;
            player.y += player.velocityY;

            // Ground collision
            const groundY = player.isCrouching ? 455 : 440;
            if (player.y >= groundY) {
                player.y = groundY;
                player.velocityY = 0;
                player.isJumping = false;
            }

            // Update bullets - OPTIMIZED WITH POOLING
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].speed;
                bullets[i].y += bullets[i].angle * bullets[i].speed;

                if (bullets[i].x > canvas.width) {
                    returnToPool('bullets', bullets[i]);
                    bullets.splice(i, 1);
                }
            }

            // Update enemies - OPTIMIZED
            for (let i = enemies.length - 1; i >= 0; i--) {
                // Helicopter-specific logic
                if (enemies[i].type === 'helicopter' || enemies[i].type === 'red_helicopter') {
                    // Move helicopter to target position (right side of screen)
                    if (enemies[i].x > enemies[i].targetX) {
                        enemies[i].x -= 3; // Move to position
                    } else {
                        enemies[i].x = enemies[i].targetX; // Lock in position
                    }

                    // Drop barrel logic (only when in position)
                    if (enemies[i].x <= enemies[i].targetX) {
                        enemies[i].dropTimer--;
                        if (enemies[i].dropTimer <= 0) {
                            // Drop explosive barrel (adjusted for 3x scale)
                            droppedBarrels.push({
                                x: enemies[i].x + 90, // Center of helicopter (30 * 3)
                                y: enemies[i].y + 135, // Bottom of helicopter (45 * 3)
                                width: 20,
                                height: 25,
                                velocityY: 2,
                                exploding: false,
                                explosionTimer: 0,
                                onGround: false // Track if barrel has landed
                            });
                            enemies[i].dropTimer = enemies[i].dropCooldown;
                        }
                    }
                } else {
                    // Normal enemy movement
                    enemies[i].x -= enemies[i].speed + game.speed;
                }

                // OPTIMIZATION: Only check collisions if enemy is on screen or near it
                const isNearScreen = enemies[i].x < canvas.width + 100 && enemies[i].x > -100;

                if (isNearScreen) {
                    // Check bullet collision
                    for (let j = bullets.length - 1; j >= 0; j--) {
                    if (bullets[j].x < enemies[i].x + enemies[i].width &&
                        bullets[j].x + bullets[j].width > enemies[i].x &&
                        bullets[j].y < enemies[i].y + enemies[i].height &&
                        bullets[j].y + bullets[j].height > enemies[i].y) {

                        enemies[i].health -= bullets[j].damage;
                        returnToPool('bullets', bullets[j]);
                        bullets.splice(j, 1);

                        if (enemies[i].health <= 0) {
                            game.score += 10;
                            game.money += 6; // Increased reward from 5 to 6
                            game.kills++; // Increment kill counter

                            // If helicopter is killed, reset flag
                            if (enemies[i].type === 'helicopter' || enemies[i].type === 'red_helicopter') {
                                game.helicopterActive = false;
                            }

                            returnToPool('enemies', enemies[i]);
                            enemies.splice(i, 1);
                            break;
                        }
                    }
                }

                    // Check player collision (adjusted for bigger werewolves)
                    if (i >= 0 && enemies[i]) {
                        const playerHeight = player.isCrouching ? 50 : 62;
                        const playerY = player.isCrouching ? player.y + 15 : player.y;

                        if (enemies[i].x < player.x + 50 &&
                            enemies[i].x + 50 > player.x &&
                            enemies[i].y < playerY + playerHeight &&
                            enemies[i].y + 90 > playerY) {

                            // Check armor first
                            if (game.armor > 0) {
                                game.armor--;
                            } else {
                                game.health--;
                            }

                            returnToPool('enemies', enemies[i]);
                            enemies.splice(i, 1);

                            if (game.health <= 0) {
                                gameOver();
                            }
                        }
                    }
                } // End of isNearScreen check

                // Remove off-screen enemies
                if (i >= 0 && enemies[i] && enemies[i].x < -enemies[i].width) {
                    // If helicopter flies off screen, reset flag
                    if (enemies[i].type === 'helicopter') {
                        game.helicopterActive = false;
                    }
                    returnToPool('enemies', enemies[i]);
                    enemies.splice(i, 1);
                    game.score += 1;
                }
            }

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= game.speed;

                // Check player collision with obstacles
                const playerHeight = player.isCrouching ? 50 : 62;
                const playerY = player.isCrouching ? player.y + 15 : player.y;
                const playerBottom = playerY + playerHeight;
                const playerRight = player.x + 45;

                // For car obstacle, the roof starts at carY + 20, not carY
                const obstacleTop = obstacles[i].type === 'car' ? obstacles[i].y + 20 : obstacles[i].y;

                // Check if there's any overlap
                const isOverlapping = obstacles[i].x < playerRight &&
                    obstacles[i].x + obstacles[i].width > player.x &&
                    obstacleTop < playerBottom &&
                    obstacles[i].y + obstacles[i].height > playerY;

                if (isOverlapping) {
                    // Check if player is coming from above (landing on top)
                    const isLandingOnTop = player.velocityY > 0 && // Falling down (must be positive velocity)
                        playerBottom - player.velocityY <= obstacleTop + 5; // Was above obstacle in previous frame

                    if (isLandingOnTop) {
                        // Landing on top - NO DAMAGE, can stand on it
                        player.y = obstacleTop - playerHeight + (player.isCrouching ? 15 : 0);
                        player.velocityY = 0;
                        player.isJumping = false;
                    } else {
                        // Side collision or ground collision - take damage (armor first)
                        if (game.armor > 0) {
                            game.armor--;
                        } else {
                            game.health--;
                        }

                        obstacles.splice(i, 1);

                        if (game.health <= 0) {
                            gameOver();
                        }
                    }
                } else if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                    game.score += 4;
                }
            }

            // Update dropped barrels
            for (let i = droppedBarrels.length - 1; i >= 0; i--) {
                const barrel = droppedBarrels[i];

                // If barrel is on ground, stop falling and act as obstacle
                if (!barrel.onGround && barrel.y >= 485) {
                    barrel.onGround = true;
                    barrel.y = 485; // Lock to ground
                    barrel.velocityY = 0;
                }

                // Move barrel down if still falling
                if (!barrel.onGround) {
                    barrel.y += barrel.velocityY;
                }

                // Always move with game speed
                barrel.x -= game.speed;

                // Handle explosion animation
                if (barrel.exploding) {
                    barrel.explosionTimer--;
                    if (barrel.explosionTimer <= 0) {
                        droppedBarrels.splice(i, 1);
                        continue;
                    }
                }

                // Check collision with player (only if not exploding yet)
                if (!barrel.exploding) {
                    const playerHeight = player.isCrouching ? 50 : 62;
                    const playerY = player.isCrouching ? player.y + 15 : player.y;

                    if (barrel.x < player.x + 50 &&
                        barrel.x + barrel.width > player.x &&
                        barrel.y < playerY + playerHeight &&
                        barrel.y + barrel.height > playerY) {

                        // Trigger explosion and damage player
                        barrel.exploding = true;
                        barrel.explosionTimer = 30;

                        // Play explosion sound
                        playExplosionSound();

                        // Damage player
                        if (game.armor > 0) {
                            game.armor--;
                        } else {
                            game.health--;
                        }

                        if (game.health <= 0) {
                            gameOver();
                        }
                    }
                }

                // Remove if off-screen
                if (barrel.x < -barrel.width) {
                    droppedBarrels.splice(i, 1);
                }
            }

            // Spawn enemies and obstacles (10% less enemies, 10% more after 3000 score)
            const enemySpawnRate = game.score >= 3000 ? 182 : 200; // 10% faster spawn after 3000 points
            if (game.frameCount % enemySpawnRate === 0) {
                spawnEnemy();
            }

            // Reduced obstacle frequency (from 200 to 300 frames)
            if (game.frameCount % 300 === 0) {
                // Obstacle spawning logic:
                // 2% chance for double obstacles (reduced from 20%)
                // 14.4% chance for car (reduced by 20% from 18%)
                // 83.6% chance for single obstacle
                const rand = Math.random();
                let obstacleCount = 1;
                let spawnCar = false;

                if (rand > 0.98) {
                    // 2% chance for double obstacles
                    obstacleCount = 2;
                } else if (rand > 0.856) {
                    // 14.4% chance for car (18% - 20% = 14.4%)
                    spawnCar = true;
                }

                if (spawnCar) {
                    // Spawn car obstacle
                    const carObstacle = spawnCarObstacle();
                } else {
                    // Spawn regular obstacles
                    for (let i = 0; i < obstacleCount; i++) {
                        const obstacle = spawnObstacle();
                        if (obstacle) {
                            obstacle.x += i * 100; // More spacing between obstacles
                        }
                    }
                }
            }

            // Spawn piggy bank building at random intervals within each 500-point cycle
            const currentCycle = Math.floor(game.score / 500);
            const scoreInCycle = game.score % 500;

            // Check if we entered a new cycle
            if (currentCycle !== game.lastPiggyBankCycle) {
                game.lastPiggyBankCycle = currentCycle;
                game.piggyBankSpawned = false;
                // Generate random spawn point within this 500-point cycle (50-450 to avoid edges)
                game.nextPiggyBank = 50 + Math.random() * 400; // Random between 50 and 450
            }

            // Spawn piggy bank at the random point in current cycle
            if (!game.piggyBankSpawned && scoreInCycle >= game.nextPiggyBank) {
                piggyBanks.push({
                    x: canvas.width,
                    y: 500 - 150,  // Ground level minus building height (increased from 120 to 150)
                    width: 520,    // Increased from 400 to 520 (1.3x)
                    height: 150,   // Increased from 120 to 150
                    broken: false,
                    trashCanX: canvas.width - 80 // Trash can position (left of building)
                });
                game.piggyBankSpawned = true;
            }

            // Helicopter spawn logic:
            // - Normal helicopters: spawn every 500 points until 2000 score
            // - Red helicopters: spawn at 2000, then every 700 points after (2700, 3400, 4100...)

            // Red helicopter spawns starting from 2000, then every 700 points
            if (game.score >= game.nextRedHelicopterScore && !game.helicopterActive) {
                spawnHelicopter(true); // Spawn red helicopter
                game.nextRedHelicopterScore += 700; // Next red helicopter in 700 points
            }
            // Normal helicopter spawns every 500 points, but only until score reaches 2000
            else if (game.score >= game.nextHelicopterScore && game.score < 2000 && !game.helicopterActive) {
                spawnHelicopter(false);
                game.nextHelicopterScore += 500;
            }

            // Spawn street lamp every 150 points
            if (game.score >= game.nextStreetLampScore) {
                streetLamps.push({
                    x: canvas.width,
                    y: 227, // Position on ground (500 - 273 for lamp height with base)
                    width: 45, // Width for hitbox (scaled 1.3x from 35)
                    height: 273 // Total height of lamp (2.6x taller: 105 * 2.6)
                });
                game.nextStreetLampScore += 100;
            }

            // Increase difficulty gradually
            if (game.frameCount % 900 === 0) {
                game.speed = Math.min(game.speed + 0.3, 9);
            }

            // Spawn basement entrance when reaching shop milestone
            if (game.score >= game.nextShopScore && !game.basementSpawned && basementEntrances.length === 0) {
                basementEntrances.push({
                    x: canvas.width + 200, // Spawn ahead on screen
                    y: 390, // Ground level
                    width: 120,
                    height: 110,
                    triggered: false, // Track if cutscene was triggered
                    enteringBasement: false // Track if pig is entering
                });
                game.basementSpawned = true; // Mark as spawned for this milestone
            }

            // Update piggy banks
            for (let i = piggyBanks.length - 1; i >= 0; i--) {
                piggyBanks[i].x -= game.speed;

                // Check bullet collision with piggy bank (only if not broken)
                if (!piggyBanks[i].broken) {
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const platformY = piggyBanks[i].y - 12;
                        const pigX = piggyBanks[i].x + piggyBanks[i].width - 120; // Right side of building
                        const pigY = platformY - 85; // Raised to match visual position

                        // Hitbox for piggy bank (larger, easier to hit)
                        if (bullets[j].x >= pigX &&
                            bullets[j].x <= pigX + 100 &&
                            bullets[j].y >= pigY &&
                            bullets[j].y <= pigY + 80) {

                            // Break piggy bank!
                            piggyBanks[i].broken = true;
                            game.money += 100;
                            returnToPool('bullets', bullets[j]);
                            bullets.splice(j, 1);
                            break;
                        }
                    }
                }

                // Platform collision - ALWAYS works, even if piggy bank is broken
                const playerBottom = player.isCrouching ? player.y + 65 : player.y + 62;
                const platformY = piggyBanks[i].y - 12; // Platform is 12px above building
                const platformX = piggyBanks[i].x - 40; // Extended 40px to the left
                const platformWidth = piggyBanks[i].width + 80; // Extended 40px on each side

                // Check horizontal overlap
                const isOverPlatform = player.x + 50 > platformX && player.x < platformX + platformWidth;

                // Check if landing from above (was above platform in previous frame)
                const wasAbovePlatform = playerBottom - player.velocityY <= platformY;
                const isAtPlatformLevel = playerBottom >= platformY && playerBottom <= platformY + 15;

                if (isOverPlatform && isAtPlatformLevel && player.velocityY > 0 && wasAbovePlatform) {
                    // Can stand on platform (roof)
                    player.y = platformY - 62 + (player.isCrouching ? 15 : 0);
                    player.velocityY = 0;
                    player.isJumping = false;
                }

                // Trash can collision - ALWAYS works
                const trashCanX = piggyBanks[i].x - 150;
                const trashCanY = 500 - 55;
                const trashCanWidth = 50;
                const trashCanHeight = 55;
                const trashCanTop = trashCanY - 8; // Including lid

                if (player.x + 50 > trashCanX &&
                    player.x < trashCanX + trashCanWidth &&
                    playerBottom >= trashCanTop &&
                    playerBottom <= trashCanTop + 10 &&
                    player.velocityY > 0) {

                    // Can stand on trash can lid
                    player.y = trashCanTop - 62 + (player.isCrouching ? 15 : 0);
                    player.velocityY = 0;
                    player.isJumping = false;
                }

                // Remove off-screen piggy banks
                if (piggyBanks[i].x < -piggyBanks[i].width) {
                    piggyBanks.splice(i, 1);
                }
            }

            // Update street lamps
            for (let i = streetLamps.length - 1; i >= 0; i--) {
                streetLamps[i].x -= game.speed;

                // Remove if off-screen
                if (streetLamps[i].x < -streetLamps[i].width) {
                    streetLamps.splice(i, 1);
                }
            }

            // Update basement entrances
            for (let i = basementEntrances.length - 1; i >= 0; i--) {
                const entrance = basementEntrances[i];
                entrance.x -= game.speed;

                // Check if basement is approaching (within 300px)
                if (!entrance.triggered && entrance.x <= player.x + 300) {
                    entrance.triggered = true;
                    entrance.enteringBasement = true;
                    game.autoRunning = true; // Disable player control
                }

                // If pig is entering basement, move pig towards entrance
                if (entrance.enteringBasement) {
                    // Move pig right automatically
                    player.x += 3;

                    // When pig reaches the entrance center, open shop
                    if (player.x >= entrance.x + entrance.width / 2) {
                        game.running = false;
                        game.autoRunning = false;
                        openShop();
                        basementEntrances.splice(i, 1);
                        continue;
                    }
                }

                // Remove if off-screen
                if (entrance.x < -entrance.width) {
                    basementEntrances.splice(i, 1);
                }
            }

            // Update UI
            updateUI();
        }

        // Draw game
        function draw() {
            drawBackground();

            // Draw bullets (brighter and more visible)
            bullets.forEach(bullet => {
                // Outer glow
                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.fillRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);

                // Main bullet
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

                // White core
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(bullet.x + 1, bullet.y + 1, Math.max(1, bullet.width - 2), Math.max(1, bullet.height - 2));
            });

            // Draw enemies
            enemies.forEach(drawEnemy);

            // Draw obstacles
            obstacles.forEach(drawObstacle);

            // Draw basement entrances
            basementEntrances.forEach(drawBasementEntrance);

            // Draw street lamps
            streetLamps.forEach(drawStreetLamp);

            // Draw dropped barrels
            droppedBarrels.forEach(barrel => {
                if (barrel.exploding) {
                    // Explosion animation (bigger and more dramatic)
                    const explosionProgress = 1 - (barrel.explosionTimer / 30);
                    const explosionSize = 80 * explosionProgress; // Increased from 40 to 80 (2x bigger)

                    // Red outer explosion (new layer)
                    ctx.fillStyle = `rgba(255, 69, 0, ${0.7 * (1 - explosionProgress)})`;
                    ctx.fillRect(
                        barrel.x - explosionSize,
                        barrel.y - explosionSize,
                        barrel.width + explosionSize * 2,
                        barrel.height + explosionSize * 2
                    );

                    // Orange explosion
                    ctx.fillStyle = `rgba(255, 140, 0, ${1 - explosionProgress})`;
                    ctx.fillRect(
                        barrel.x - explosionSize * 0.7,
                        barrel.y - explosionSize * 0.7,
                        barrel.width + explosionSize * 1.4,
                        barrel.height + explosionSize * 1.4
                    );

                    // Yellow inner explosion
                    ctx.fillStyle = `rgba(255, 215, 0, ${1 - explosionProgress})`;
                    ctx.fillRect(
                        barrel.x - explosionSize * 0.4,
                        barrel.y - explosionSize * 0.4,
                        barrel.width + explosionSize * 0.8,
                        barrel.height + explosionSize * 0.8
                    );

                    // White core (bigger)
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - explosionProgress})`;
                    ctx.fillRect(
                        barrel.x + barrel.width * 0.15,
                        barrel.y + barrel.height * 0.15,
                        barrel.width * 0.7,
                        barrel.height * 0.7
                    );
                } else {
                    // Draw falling barrel (explosive, red)
                    ctx.fillStyle = '#8B0000'; // Dark red
                    ctx.fillRect(barrel.x, barrel.y, barrel.width, barrel.height);

                    // Top/bottom bands
                    ctx.fillStyle = '#CD853F';
                    ctx.fillRect(barrel.x, barrel.y, barrel.width, 4);
                    ctx.fillRect(barrel.x, barrel.y + barrel.height - 4, barrel.width, 4);

                    // Warning symbol (!)
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(barrel.x + barrel.width / 2 - 2, barrel.y + 8, 4, 8);
                    ctx.fillRect(barrel.x + barrel.width / 2 - 2, barrel.y + 18, 4, 3);
                }
            });

            // Draw piggy banks (medium-sized building with platform on top)
            piggyBanks.forEach(bank => {
                // Draw trash can (left of building for easy access)
                const trashCanX = bank.x - 150;
                const trashCanY = 500 - 55; // Ground level minus trash can height
                const trashCanWidth = 50;
                const trashCanHeight = 55;

                // Main trash can body (dark gray)
                ctx.fillStyle = '#3A3A3A';
                ctx.fillRect(trashCanX, trashCanY, trashCanWidth, trashCanHeight);

                // Trash can lid (lighter gray)
                ctx.fillStyle = '#5A5A5A';
                ctx.fillRect(trashCanX - 5, trashCanY - 8, trashCanWidth + 10, 10);

                // Lid handle
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(trashCanX + trashCanWidth/2 - 8, trashCanY - 12, 16, 6);

                // Trash can stripes (darker)
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(trashCanX, trashCanY + 15, trashCanWidth, 4);
                ctx.fillRect(trashCanX, trashCanY + 35, trashCanWidth, 4);

                // Trash can border
                ctx.strokeStyle = '#2A2A2A';
                ctx.lineWidth = 2;
                ctx.strokeRect(trashCanX, trashCanY, trashCanWidth, trashCanHeight);

                // Jump indicator arrow above trash can
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 32px Courier New';
                ctx.fillText('‚Üë', trashCanX + trashCanWidth/2 - 10, trashCanY - 20);

                // Pulsing glow effect for jump indicator
                const pulseAlpha = 0.3 + Math.sin(game.frameCount * 0.1) * 0.2;
                ctx.globalAlpha = pulseAlpha;
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(trashCanX - 5, trashCanY - 5, trashCanWidth + 10, trashCanHeight + 10);
                ctx.globalAlpha = 1.0;

                // Draw building - solid, opaque
                ctx.globalAlpha = 1.0;

                // Main building body (dark gray/charcoal)
                ctx.fillStyle = '#3A3A3A'; // Dark charcoal gray
                ctx.fillRect(bank.x, bank.y, bank.width, bank.height);

                // Building pillars/edges (darker gray)
                ctx.fillStyle = '#2A2A2A'; // Very dark gray for pillars
                ctx.fillRect(bank.x, bank.y, 15, bank.height);
                ctx.fillRect(bank.x + bank.width - 15, bank.y, 15, bank.height);

                // Door
                ctx.fillStyle = '#1A1A1A'; // Almost black for door
                const doorWidth = 40;
                const doorHeight = 60;
                const doorX = bank.x + bank.width/2 - doorWidth/2;
                ctx.fillRect(doorX, bank.y + bank.height - doorHeight, doorWidth, doorHeight);

                // Door frame
                ctx.strokeStyle = '#2A2A2A';
                ctx.lineWidth = 3;
                ctx.strokeRect(doorX, bank.y + bank.height - doorHeight, doorWidth, doorHeight);

                // Roof detail
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(bank.x - 10, bank.y - 10, bank.width + 20, 15);

                // Windows (golden glow, 2 rows)
                ctx.fillStyle = '#FFD700';
                const windowSize = 14;
                const windowSpacing = 50;
                const windowsPerRow = Math.floor((bank.width - 60) / windowSpacing);

                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < windowsPerRow; col++) {
                        const wx = bank.x + 40 + col * windowSpacing;
                        const wy = bank.y + 20 + row * 35;

                        // Don't draw window over door
                        if (!(row === 1 && wx > doorX - 20 && wx < doorX + doorWidth + 20)) {
                            ctx.fillRect(wx, wy, windowSize, windowSize);
                            // Window panes
                            ctx.strokeStyle = '#DAA520';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(wx, wy, windowSize, windowSize);
                        }
                    }
                }

                // Bank sign
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 24px Courier New';
                ctx.fillText('BANK', bank.x + bank.width/2 - 35, bank.y + 15);

                ctx.globalAlpha = 1.0;

                // Draw platform on top (solid, can stand on it) - extends beyond building edges
                const platformY = bank.y - 12;
                const platformX = bank.x - 40; // Extend 40px to the left
                const platformWidth = bank.width + 80; // Extend 40px on each side

                ctx.fillStyle = '#2A2A2A'; // Dark gray platform to match building
                ctx.fillRect(platformX, platformY, platformWidth, 12);
                ctx.strokeStyle = '#1A1A1A';
                ctx.lineWidth = 3;
                ctx.strokeRect(platformX, platformY, platformWidth, 12);

                // Platform edge details
                ctx.fillStyle = '#3A3A3A';
                for (let i = 0; i < platformWidth; i += 30) {
                    ctx.fillRect(platformX + i, platformY, 4, 12);
                }

                // Railings on platform edges (left and right)
                ctx.fillStyle = '#4A4A4A';
                ctx.lineWidth = 3;

                // Left railing
                ctx.fillRect(platformX, platformY - 25, 4, 25); // Vertical post
                ctx.fillRect(platformX, platformY - 25, 30, 4); // Horizontal rail

                // Right railing
                ctx.fillRect(platformX + platformWidth - 4, platformY - 25, 4, 25); // Vertical post
                ctx.fillRect(platformX + platformWidth - 30, platformY - 25, 30, 4); // Horizontal rail

                // Platform surface highlight (makes it more visible)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(platformX, platformY, platformWidth, 3);

                if (!bank.broken) {
                    // Piggy bank on platform - increased 1.5x, lowered for easier shooting
                    const pigX = bank.x + bank.width - 120; // Right side of building (adjusted for larger size)
                    const pigY = platformY - 85; // Raised higher on platform

                    // Body (50x30 -> 75x45)
                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(pigX, pigY + 22, 75, 45);

                    // Head (25x25 -> 37x37)
                    ctx.fillRect(pigX + 52, pigY + 12, 37, 37);

                    // Snout (10x10 -> 15x15)
                    ctx.fillStyle = '#FF69B4';
                    ctx.fillRect(pigX + 82, pigY + 24, 15, 15);

                    // Coin slot (20x4 -> 30x6)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pigX + 27, pigY + 18, 30, 6);

                    // Legs (10x10 -> 15x15)
                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(pigX + 12, pigY + 63, 15, 15);
                    ctx.fillRect(pigX + 37, pigY + 63, 15, 15);
                    ctx.fillRect(pigX + 63, pigY + 63, 15, 15);

                    // $ symbol (increased font size)
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 33px Courier New';
                    ctx.fillText('$100', pigX + 12, pigY + 52);

                    // Glow effect around piggy bank (70x55 -> 105x82)
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pigX - 7, pigY + 7, 105, 82);
                    ctx.globalAlpha = 1.0;
                } else {
                    // Broken piggy bank pieces (1.5x larger)
                    const pigX = bank.x + bank.width - 120; // Right side of building (same as intact)
                    const pigY = platformY - 85; // Raised to match intact piggy bank position

                    ctx.fillStyle = '#FFB6C1';
                    // Pieces scaled 1.5x (18x15 -> 27x22)
                    ctx.fillRect(pigX + 15, pigY + 37, 27, 22);
                    // (20x18 -> 30x27)
                    ctx.fillRect(pigX + 52, pigY + 45, 30, 27);
                    // (15x12 -> 22x18)
                    ctx.fillRect(pigX + 27, pigY + 60, 22, 18);

                    // Coins scattered (8x8 -> 12x12)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pigX + 22, pigY + 48, 12, 12);
                    ctx.fillRect(pigX + 48, pigY + 57, 12, 12);
                    ctx.fillRect(pigX + 67, pigY + 54, 12, 12);
                }
            });

            // Draw player
            drawPig();

            // Shop warning when close to milestone (no yellow filter)
            const scoreUntilShop = game.nextShopScore - game.score;
            if (scoreUntilShop <= 100 && scoreUntilShop > 0) {
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 40px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText('üè™ SHOP NEARBY! üè™', canvas.width / 2, 80);
                ctx.fillText('üè™ SHOP NEARBY! üè™', canvas.width / 2, 80);
                ctx.font = 'bold 25px Courier New';
                ctx.fillStyle = '#FFD700';
                ctx.strokeText(`${scoreUntilShop} points left`, canvas.width / 2, 130);
                ctx.fillText(`${scoreUntilShop} points left`, canvas.width / 2, 130);
            }

            // Countdown timer
            if (game.countdown > 0) {
                const countNum = Math.ceil(game.countdown / 60);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 120px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 5;
                ctx.strokeText(countNum, canvas.width / 2, canvas.height / 2);
                ctx.fillText(countNum, canvas.width / 2, canvas.height / 2);
            }

            // Reload indicator
            if (game.isReloading) {
                const reloadPercent = (weapons[game.weapon].reloadTime - game.reloadProgress) / weapons[game.weapon].reloadTime;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 150, canvas.height - 80, 300, 40);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(canvas.width / 2 - 145, canvas.height - 75, 290 * reloadPercent, 30);
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('RELOADING...', canvas.width / 2, canvas.height - 52);
            }

            // Pump indicator (shotgun)
            if (game.isPumping) {
                ctx.fillStyle = '#FFA500';
                ctx.font = 'bold 30px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText('PUMPING!', canvas.width / 2, canvas.height / 2);
                ctx.fillText('PUMPING!', canvas.width / 2, canvas.height / 2);
            }

            // Draw cutscene if active
            if (game.cutsceneActive) {
                drawBasement();

                // Always draw counters in basement
                drawShopCounter(shopCounters.weapons);
                drawShopCounter(shopCounters.equipment);
                drawSuperUsdSafe();

                // Always draw merchant on right side (behind counters)
                drawMerchant(canvas.width - 150, 260);

                // Draw pig with proper model
                if (game.cutscenePhase === 0) {
                    // Pig running in from left
                    const tempPlayerX = player.x;
                    const tempPlayerY = player.y;
                    player.x = game.pigX;
                    player.y = 390; // On the floor (450 - 60 height)

                    drawPig(); // Use actual pig drawing function

                    player.x = tempPlayerX;
                    player.y = tempPlayerY;

                    // Show "Entering basement..." text
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 30px Courier New';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.strokeText('Entering basement...', canvas.width / 2, 50);
                    ctx.fillText('Entering basement...', canvas.width / 2, 50);
                } else if (game.cutscenePhase === 1) {
                    // Pig standing in front (dialog phase) - position to not block counters
                    const tempPlayerX = player.x;
                    const tempPlayerY = player.y;
                    player.x = 70;  // Far left, not blocking counters
                    player.y = 390; // On the floor (450 - 60 height)

                    drawPig(); // Use actual pig drawing function

                    player.x = tempPlayerX;
                    player.y = tempPlayerY;
                } else if (game.cutscenePhase === 2) {
                    // Shop phase - draw items on counters (without tooltips first)
                    shopCounters.weapons.items.forEach(item => {
                        const isHovered = game.hoveredItem && game.hoveredItem.id === item.id;
                        drawWeaponOnCounter(item.id, item.x, item.y, item.width, item.height, isHovered);
                    });

                    shopCounters.equipment.items.forEach(item => {
                        const isHovered = game.hoveredItem && game.hoveredItem.id === item.id;
                        if (item.id === 'armor') {
                            drawArmorOnCounter(item.x, item.y, item.width, item.height, isHovered);
                        } else if (item.id === 'health') {
                            drawHealthOnCounter(item.x, item.y, item.width, item.height, isHovered);
                        }
                    });

                    // Draw pig in front left (not blocking counters)
                    const tempPlayerX = player.x;
                    const tempPlayerY = player.y;
                    player.x = 40;  // Very far left
                    player.y = 380;
                    drawPig();
                    player.x = tempPlayerX;
                    player.y = tempPlayerY;

                    // Draw tooltip LAST so it appears on top of everything
                    if (game.hoveredItem) {
                        drawItemTooltip(game.hoveredItem, game.hoveredItem.x, game.hoveredItem.y);
                    }

                    // Draw instructions
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('Hover items to see details | Click to buy | ESC to exit', canvas.width / 2, 50);
                    ctx.fillText(`Money: $${game.money}`, canvas.width / 2, 490);
                }
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('money').textContent = game.money;
            document.getElementById('health').textContent = game.health;
            document.getElementById('weapon').textContent = weapons[game.weapon].name;
            document.getElementById('level').textContent = game.level + 1;
            document.getElementById('nextShop').textContent = game.nextShopScore;
            document.getElementById('armor').textContent = game.armor;

            // Show/hide armor display based on whether player has armor
            const armorDisplay = document.getElementById('armorDisplay');
            if (game.armor > 0) {
                armorDisplay.style.display = 'inline';
            } else {
                armorDisplay.style.display = 'none';
            }

            // Update ammo display
            const weapon = weapons[game.weapon];
            const ammoDisplay = document.getElementById('ammo');
            if (game.isReloading) {
                ammoDisplay.textContent = 'RELOADING...';
                ammoDisplay.style.color = '#FF6B6B';
            } else if (game.isPumping) {
                ammoDisplay.textContent = 'PUMPING...';
                ammoDisplay.style.color = '#FFA500';
            } else {
                ammoDisplay.textContent = `${game.currentAmmo}/${weapon.magSize}`;
                ammoDisplay.style.color = game.currentAmmo === 0 ? '#FF0000' : '#FFD700';
            }
        }

        // Game over
        function gameOver() {
            game.running = false;

            // Stop background music
            backgroundMusic.pause();

            // Save game statistics
            GameStats.saveAttempt(game.score, game.money, game.level, weapons[game.weapon].name, game.kills);

            document.getElementById('finalScore').textContent = game.score;
            document.getElementById('finalMoney').textContent = game.money;
            document.getElementById('gameOver').classList.add('active');

            // Disable buttons for 1 second to prevent accidental clicks
            const restartBtn = document.getElementById('restart');
            const mainMenuBtn = document.getElementById('mainMenuButton');
            restartBtn.disabled = true;
            mainMenuBtn.disabled = true;
            restartBtn.style.opacity = '0.5';
            mainMenuBtn.style.opacity = '0.5';
            restartBtn.style.cursor = 'not-allowed';
            mainMenuBtn.style.cursor = 'not-allowed';

            setTimeout(() => {
                restartBtn.disabled = false;
                mainMenuBtn.disabled = false;
                restartBtn.style.opacity = '1';
                mainMenuBtn.style.opacity = '1';
                restartBtn.style.cursor = 'pointer';
                mainMenuBtn.style.cursor = 'pointer';
            }, 1000);

            // Stop background music on game over
            // stopBackgroundMusic(); // Music disabled
        }

        // Start game
        function startGame() {
            game.running = true;
            game.score = 0;
            game.money = 0;
            game.health = 5;
            game.speed = 3;
            game.frameCount = 0;
            game.weapon = 'colt';
            game.currentAmmo = 7;
            game.isReloading = false;
            game.reloadProgress = 0;
            game.isPumping = false;
            game.pumpProgress = 0;
            game.level = 0;
            game.nextShopScore = 500;
            game.ownedWeapons = ['colt'];
            game.lastShot = false;
            game.armor = 0;
            game.maxHealth = 5;
            game.nextPiggyBank = Math.random() * 500;
            game.piggyBankSpawned = false;
            game.kills = 0; // Reset kill counter
            game.helicopterActive = false; // Reset helicopter flag
            game.nextHelicopterScore = 500; // Reset helicopter spawn milestone
            game.nextRedHelicopterScore = 2000; // Reset red helicopter spawn milestone
            game.nextStreetLampScore = 100; // Reset street lamp spawn milestone
            game.cutsceneActive = false; // Reset cutscene
            game.cutscenePhase = 0;
            game.cutsceneTimer = 0;
            game.pigX = 100;
            game.basementSpawned = false; // Reset basement spawn flag
            game.autoRunning = false; // Reset auto-running flag
            game.investment = 0; // Reset investment
            game.pendingPayout = 0; // Reset pending payout

            player.x = 100; // Reset player position to left side
            player.y = 440;
            player.velocityY = 0;
            player.isJumping = false;

            bullets.length = 0;
            enemies.length = 0;
            obstacles.length = 0;
            piggyBanks.length = 0;
            droppedBarrels.length = 0; // Clear dropped barrels
            streetLamps.length = 0; // Clear street lamps
            basementEntrances.length = 0; // Clear basement entrances

            document.getElementById('gameOver').classList.remove('active');
            document.getElementById('shop').classList.remove('active');
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('merchantDialog').style.display = 'none';
            updateUI();

            // Start background music
            if (game.musicEnabled) {
                backgroundMusic.currentTime = 0; // Reset to start
                backgroundMusic.play().catch(err => console.log('Music play failed:', err));
            }
        }

        // Shop functions
        function openShop() {
            // Start cutscene instead of directly opening shop
            game.cutsceneActive = true;
            game.cutscenePhase = 0;
            game.cutsceneTimer = 0;
            game.pigX = -50; // Start pig off-screen left for running animation
            game.running = false;

            // Calculate investment payout when entering new shop
            if (game.investment > 0) {
                game.pendingPayout = Math.floor(game.investment * 1.5);
                game.investment = 0; // Clear investment after calculating payout
            }

            // Prepare shop for when player accepts
            document.getElementById('shopLevel').textContent = game.level + 1;
            updateShopUI();

            // Music continues playing in shop
        }

        function actuallyOpenShop() {
            // This is called when player accepts merchant's offer
            // Instead of showing HTML shop, stay in cutscene and show counters
            game.cutscenePhase = 2; // Shop phase
            game.inShop = true;
            document.getElementById('merchantDialog').style.display = 'none';
            // Hide UI panel
            document.getElementById('ui').style.display = 'none';
        }

        function closeShop() {
            document.getElementById('shop').classList.remove('active');

            // Move to next level
            game.level++;
            if (game.level < game.shopMilestones.length) {
                game.nextShopScore = game.shopMilestones[game.level];
            } else {
                // After all milestones (after 12000), add 3000 to each next milestone
                game.nextShopScore += 3000;
            }

            // Reset basement spawned flag for next milestone
            game.basementSpawned = false;

            // Show UI panel again
            document.getElementById('ui').style.display = 'block';

            // Start countdown: 3-2-1
            game.countdown = 180; // 3 seconds at 60fps
            updateUI();
        }

        // SuperUSD Investment functions
        function openSuperUsdModal() {
            const modal = document.getElementById('superUsdModal');
            modal.style.display = 'block';
            updateInvestmentUI();
        }

        function closeSuperUsdModal() {
            document.getElementById('superUsdModal').style.display = 'none';
        }

        function updateInvestmentUI() {
            document.getElementById('investAvailable').textContent = game.money;
            document.getElementById('currentInvestment').textContent = game.investment;
            // Button is always green and clickable - logic handled in click event
        }

        function investMoney(amount) {
            if (amount === 'all') {
                amount = game.money;
            }

            if (game.money >= amount && amount > 0) {
                game.money -= amount;
                game.investment += amount;
                playButtonSound('purchase');
                updateInvestmentUI();
                updateUI();
            } else {
                playButtonSound('error');
            }
        }

        function withdrawInvestment() {
            if (game.investment > 0) {
                game.money += game.investment;
                game.investment = 0;
                playButtonSound('purchase');
                updateInvestmentUI();
                updateUI();
            } else {
                playButtonSound('error');
            }
        }

        function buyItemFromCounter(itemId) {
            // Buy item from interactive counter
            if (itemId === 'health') {
                buyItem('health', 100);
            } else if (itemId === 'armor') {
                buyItem('armor', 100);
            } else if (itemId in weapons) {
                const weapon = weapons[itemId];
                buyItem(itemId, weapon.price);
            }
        }

        function buyItem(item, cost) {
            if (item === 'health') {
                if (game.money >= cost && game.health < game.maxHealth) {
                    playButtonSound('purchase');
                    game.money -= cost;
                    game.health = Math.min(game.health + 1, game.maxHealth); // Only +1 HP now
                    updateUI();
                    updateShopUI();
                } else {
                    playButtonSound('error');
                }
            } else if (item === 'armor') {
                if (game.money >= cost) {
                    playButtonSound('purchase');
                    game.money -= cost;
                    game.armor++;
                    updateUI();
                } else {
                    playButtonSound('error');
                }
            } else {
                // Weapon purchase
                const weapon = item;
                if (!game.ownedWeapons.includes(weapon)) {
                    if (game.money >= cost) {
                        playButtonSound('purchase');
                        game.money -= cost;
                        game.ownedWeapons.push(weapon);
                        game.weapon = weapon;
                        game.currentAmmo = weapons[weapon].magSize;
                        game.isReloading = false;
                        updateUI();
                        updateShopUI();
                    } else {
                        playButtonSound('error');
                    }
                } else {
                    // Already owned - just switch to it
                    playButtonSound('click');
                    game.weapon = weapon;
                    game.currentAmmo = weapons[weapon].magSize;
                    game.isReloading = false;
                    updateUI();
                }
            }
        }

        function updateShopUI() {
            // Update Health button
            const healthBtn = document.getElementById('buyHealth');
            if (game.health >= game.maxHealth) {
                healthBtn.style.opacity = '0.5';
                healthBtn.querySelector('div:last-child').textContent = 'MAX HEALTH REACHED';
            } else {
                healthBtn.style.opacity = '1';
                healthBtn.querySelector('div:last-child').textContent = 'Price: $100';
            }

            // Update Colt button
            const coltBtn = document.getElementById('buyColt');
            if (game.ownedWeapons.includes('colt')) {
                coltBtn.style.opacity = '0.6';
                coltBtn.querySelector('div:last-child').textContent = game.weapon === 'colt' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            }

            // Update Shotgun button
            const shotgunBtn = document.getElementById('buyShotgun');
            if (game.ownedWeapons.includes('shotgun')) {
                shotgunBtn.style.opacity = '0.6';
                shotgunBtn.querySelector('div:last-child').textContent = game.weapon === 'shotgun' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            } else {
                shotgunBtn.querySelector('div:last-child').textContent = '6 rounds | Damage: 3x5 | Price: $200';
            }

            // Update Sniper button
            const sniperBtn = document.getElementById('buySniper');
            if (game.ownedWeapons.includes('sniper')) {
                sniperBtn.style.opacity = '0.6';
                sniperBtn.querySelector('div:last-child').textContent = game.weapon === 'sniper' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            } else {
                sniperBtn.querySelector('div:last-child').textContent = '5 rounds | Damage: 5 | Price: $200';
            }

            // Update Tommy button
            const tommyBtn = document.getElementById('buyTommy');
            if (game.ownedWeapons.includes('tommy')) {
                tommyBtn.style.opacity = '0.6';
                tommyBtn.querySelector('div:last-child').textContent = game.weapon === 'tommy' ? 'Equipped ‚úì' : 'You own this ‚úì (click to equip)';
            } else {
                tommyBtn.querySelector('div:last-child').textContent = '50 rounds | Damage: 1 | Price: $350';
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            // Handle ESC in shop
            if (e.key === 'Escape' && game.inShop && game.cutscenePhase === 2) {
                game.inShop = false;
                game.cutsceneActive = false;
                game.hoveredItem = null;
                closeShop();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;

            // Handle shop clicks
            if (game.inShop && game.cutscenePhase === 2) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Check if clicked on SuperUSD safe
                const safe = shopCounters.superusd;
                const safeX = safe.safeX;
                const safeY = safe.safeY;
                const safeWidth = safe.safeWidth;
                const safeHeight = safe.safeHeight;

                if (mouseX >= safeX && mouseX <= safeX + safeWidth &&
                    mouseY >= safeY && mouseY <= safeY + safeHeight) {
                    // Open SuperUSD investment modal
                    openSuperUsdModal();
                    return;
                }

                // Check if clicked on any item
                const allItems = [
                    ...shopCounters.weapons.items,
                    ...shopCounters.equipment.items
                ];

                for (const item of allItems) {
                    if (mouseX >= item.x && mouseX <= item.x + item.width &&
                        mouseY >= item.y && mouseY <= item.y + item.height) {
                        // Buy item
                        buyItemFromCounter(item.id);
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => mouseDown = false);

        canvas.addEventListener('mousemove', (e) => {
            if (game.inShop && game.cutscenePhase === 2) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                game.mouseX = mouseX;
                game.mouseY = mouseY;

                // Check hover on items
                game.hoveredItem = null;

                // Check hover on SuperUSD safe
                const safe = shopCounters.superusd;
                const safeX = safe.safeX;
                const safeY = safe.safeY;
                const safeWidth = safe.safeWidth;
                const safeHeight = safe.safeHeight;

                if (mouseX >= safeX && mouseX <= safeX + safeWidth &&
                    mouseY >= safeY && mouseY <= safeY + safeHeight) {
                    canvas.style.cursor = 'pointer';
                    return;
                }

                const allItems = [
                    ...shopCounters.weapons.items,
                    ...shopCounters.equipment.items
                ];

                for (const item of allItems) {
                    if (mouseX >= item.x && mouseX <= item.x + item.width &&
                        mouseY >= item.y && mouseY <= item.y + item.height) {
                        game.hoveredItem = item;
                        canvas.style.cursor = 'pointer';
                        break;
                    }
                }

                if (!game.hoveredItem) {
                    canvas.style.cursor = 'default';
                }
            } else {
                canvas.style.cursor = 'default';
            }
        });

        // Merchant dialog event listeners
        document.getElementById('acceptShop').addEventListener('click', () => {
            playButtonSound('click');
            actuallyOpenShop();
        });

        document.getElementById('declineShop').addEventListener('click', () => {
            playButtonSound('click');
            // Close dialog and skip shop
            document.getElementById('merchantDialog').style.display = 'none';
            game.cutsceneActive = false;
            closeShop(); // Continue to next level
        });

        document.getElementById('askRestock').addEventListener('click', () => {
            playButtonSound('click');
            const dialog = document.getElementById('merchantDialog');

            // Check if player already asked this question before
            if (game.hasAskedRestock) {
                // Angry response - second time asking
                dialog.innerHTML = `
                    <div style="position: absolute; right: -20px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 20px solid #FFD700; border-top: 15px solid transparent; border-bottom: 15px solid transparent;"></div>
                    <div style="position: absolute; right: -15px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 15px solid #1a1a1a; border-top: 12px solid transparent; border-bottom: 12px solid transparent;"></div>
                    <h2 style="margin-bottom: 15px; text-shadow: 2px 2px 0px #000000; font-size: 24px;">üë§ Crouton üò†</h2>
                    <p style="font-size: 18px; margin-bottom: 25px; color: #FF4444; line-height: 1.5; font-weight: bold;">I already answered your question!<br>GET OUT OF HERE!</p>
                    <div style="text-align: center;">
                        <button id="okAngry" style="padding: 12px 30px; font-size: 16px; background: #8B0000; color: #FFF; border: 3px solid #FF0000; cursor: pointer; font-weight: bold;">But I just asked...</button>
                    </div>
                `;

                // Add event listener - kick player out of shop
                document.getElementById('okAngry').addEventListener('click', () => {
                    playButtonSound('click');
                    document.getElementById('merchantDialog').style.display = 'none';
                    game.cutsceneActive = false;
                    closeShop(); // Exit shop
                });
            } else {
                // First time asking - show SOON
                game.hasAskedRestock = true; // Mark as asked

                dialog.innerHTML = `
                    <div style="position: absolute; right: -20px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 20px solid #FFD700; border-top: 15px solid transparent; border-bottom: 15px solid transparent;"></div>
                    <div style="position: absolute; right: -15px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-left: 15px solid #1a1a1a; border-top: 12px solid transparent; border-bottom: 12px solid transparent;"></div>
                    <h2 style="margin-bottom: 15px; text-shadow: 2px 2px 0px #000000; font-size: 24px;">üë§ Crouton</h2>
                    <div style="text-align: center; margin: 30px 0;">
                        <p style="font-size: 80px; font-weight: bold; color: #FFD700; text-shadow: 4px 4px 0px #000000, 0 0 20px #FFD700; letter-spacing: 5px; margin: 0;">SOON</p>
                    </div>
                    <div style="text-align: center;">
                        <button id="okRestock" style="padding: 12px 30px; font-size: 16px; background: #FFD700; color: #000; border: 3px solid #FFA500; cursor: pointer; font-weight: bold;">Got it!</button>
                    </div>
                `;

                // Add event listener for the "Got it!" button - close dialog and open shop
                document.getElementById('okRestock').addEventListener('click', () => {
                    playButtonSound('click');
                    document.getElementById('merchantDialog').style.display = 'none';
                    // Open shop properly so player can buy items
                    actuallyOpenShop();
                });
            }
        });

        document.getElementById('closeShop').addEventListener('click', () => {
            playButtonSound('click');
            // Payout is calculated when opening next shop, not when closing current one
            closeShop();
        });

        // SuperUSD modal event listeners
        document.querySelectorAll('.invest-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const amount = btn.getAttribute('data-amount');
                if (amount === 'all') {
                    investMoney('all');
                } else {
                    investMoney(parseInt(amount));
                }
            });
        });

        document.getElementById('withdrawInvestment').addEventListener('click', () => {
            withdrawInvestment();
        });

        document.getElementById('collectPayout').addEventListener('click', () => {
            if (game.pendingPayout > 0) {
                playButtonSound('purchase');
                game.money += game.pendingPayout;
                game.pendingPayout = 0;
                updateUI();
                updateInvestmentUI();
            } else {
                // No profit available - just play click sound
                playButtonSound('click');
            }
        });

        document.getElementById('closeSuperUsd').addEventListener('click', () => {
            playButtonSound('click');
            closeSuperUsdModal();
        });

        document.getElementById('buyHealth').addEventListener('click', () => {
            buyItem('health', 100);
        });

        document.getElementById('buyArmor').addEventListener('click', () => {
            buyItem('armor', 100);
        });

        document.getElementById('buyColt').addEventListener('click', () => {
            buyItem('colt', 0);
        });

        document.getElementById('buyShotgun').addEventListener('click', () => {
            buyItem('shotgun', 200);
        });

        document.getElementById('buySniper').addEventListener('click', () => {
            buyItem('sniper', 200);
        });

        document.getElementById('buyTommy').addEventListener('click', () => {
            buyItem('tommy', 350);
        });

        document.getElementById('restart').addEventListener('click', (e) => {
            if (e.target.disabled) return;
            playButtonSound('click');
            startGame();
        });

        document.getElementById('mainMenuButton').addEventListener('click', (e) => {
            if (e.target.disabled) return;
            playButtonSound('click');
            document.getElementById('gameOver').classList.remove('active');
            document.getElementById('mainMenu').classList.remove('hidden');
            game.running = false;

            // Stop background music
            backgroundMusic.pause();
        });

        // Main Menu event listeners
        document.getElementById('startButton').addEventListener('click', () => {
            playButtonSound('click');
            document.getElementById('mainMenu').classList.add('hidden');
            startGame();
        });

        document.getElementById('settingsButton').addEventListener('click', () => {
            playButtonSound('click');
            document.getElementById('settingsMenu').classList.add('active');
        });

        document.getElementById('closeSettings').addEventListener('click', () => {
            playButtonSound('click');
            document.getElementById('settingsMenu').classList.remove('active');
        });

        // Statistics button
        document.getElementById('statsButton').addEventListener('click', () => {
            playButtonSound('click');
            openStatsMenu();
        });

        document.getElementById('closeStats').addEventListener('click', () => {
            playButtonSound('click');
            document.getElementById('statsMenu').classList.remove('active');
        });

        document.getElementById('clearStats').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all statistics? This cannot be undone!')) {
                playButtonSound('click');
                GameStats.clearStats();
                openStatsMenu(); // Refresh the stats display
            }
        });

        // Function to open and populate stats menu
        function openStatsMenu() {
            const stats = GameStats.loadStats();

            // Update overall stats
            document.getElementById('bestScore').textContent = GameStats.getBestScore();
            document.getElementById('totalGames').textContent = GameStats.getTotalGames();
            document.getElementById('totalMoney').textContent = '$' + GameStats.getTotalMoney();

            // Calculate total kills
            const totalKills = stats.reduce((sum, s) => sum + (s.kills || 0), 0);
            document.getElementById('totalKills').textContent = totalKills;

            // Display recent games
            const recentGamesDiv = document.getElementById('recentGames');
            if (stats.length === 0) {
                recentGamesDiv.innerHTML = '<div style="text-align: center; color: #FFB6C1; padding: 20px;">No games played yet. Start playing to see your stats!</div>';
            } else {
                // Sort by timestamp (newest first)
                const sortedStats = [...stats].sort((a, b) => b.timestamp - a.timestamp);

                recentGamesDiv.innerHTML = sortedStats.map(attempt => `
                    <div class="stats-game-item">
                        <div>
                            <div class="stat-label">Date</div>
                            <div class="stat-value" style="font-size: 12px;">${attempt.date}</div>
                        </div>
                        <div>
                            <div class="stat-label">Score</div>
                            <div class="stat-value">${attempt.score}</div>
                        </div>
                        <div>
                            <div class="stat-label">Money</div>
                            <div class="stat-value">$${attempt.money}</div>
                        </div>
                        <div>
                            <div class="stat-label">Kills</div>
                            <div class="stat-value">${attempt.kills || 0}</div>
                        </div>
                    </div>
                `).join('');
            }

            document.getElementById('statsMenu').classList.add('active');
        }

        // Volume control
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');

        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value;
            game.volume = volume / 100; // Convert to 0.0 - 1.0
            volumeValue.textContent = volume + '%';
        });

        // Music volume slider
        const musicVolumeSlider = document.getElementById('musicVolumeSlider');
        const musicVolumeValue = document.getElementById('musicVolumeValue');

        musicVolumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value;
            game.musicVolume = volume / 100; // Convert to 0.0 - 1.0
            musicVolumeValue.textContent = volume + '%';
            backgroundMusic.volume = game.musicVolume;
        });

        // Music toggle button
        const musicToggle = document.getElementById('musicToggle');

        musicToggle.addEventListener('click', () => {
            game.musicEnabled = !game.musicEnabled;
            musicToggle.textContent = game.musicEnabled ? 'ON' : 'OFF';

            if (game.musicEnabled && game.running) {
                backgroundMusic.play().catch(err => console.log('Music play failed:', err));
            } else {
                backgroundMusic.pause();
            }
        });

        // Shop tab switching
        const shopTabs = document.querySelectorAll('.shop-tab');
        const shopContents = document.querySelectorAll('.shop-content');

        shopTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                playButtonSound('click');
                // Remove active class from all tabs and contents
                shopTabs.forEach(t => t.classList.remove('active'));
                shopContents.forEach(c => c.classList.remove('active'));

                // Add active class to clicked tab
                tab.classList.add('active');

                // Show corresponding content
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(tabName + '-content').classList.add('active');
            });
        });

        // Initialize and start
        initBuildings();
        gameLoop();

        // Don't auto-start game, wait for menu interaction
        // startGame(); // Removed - game starts from menu now
    </script>
</body>
</html>